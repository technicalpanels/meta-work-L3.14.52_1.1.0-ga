From 8f568475e18f608dbe5d28690a7ae02227130759 Mon Sep 17 00:00:00 2001
From: leavs <leavs_o@126.com>
Date: Wed, 7 Feb 2018 17:42:30 +0800
Subject: [PATCH 1/4] keep logo from uboot to kernel


diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index cb770c3..6866a8c 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -164,6 +164,10 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx6dl-sabresd-enetirq.dtb \
 	imx6dl-sabresd-ldo.dtb \
 	imx6dl-sabresd-pf200.dtb \
+	imx6dl-sabresd-logo-lcd-ipu1-di0.dtb \
+	imx6dl-sabresd-logo-lvds-ipu1-di0.dtb \
+	imx6dl-sabresd-logo-lvds-ipu1-di1.dtb \
+	imx6dl-sabresd-logo-hdmi-ipu1-di0.dtb \
 	imx6dl-sabresd-hdcp.dtb \
 	imx6dl-wandboard.dtb \
 	imx6q-arm2.dtb \
@@ -190,6 +194,12 @@ dtb-$(CONFIG_ARCH_MXC) += \
 	imx6q-sbc6x.dtb \
 	imx6q-udoo.dtb \
 	imx6q-wandboard.dtb \
+	imx6q-sabresd-logo-lcd-ipu1-di0.dtb \
+	imx6q-sabresd-logo-lvds-ipu1-di0.dtb \
+	imx6q-sabresd-logo-lvds-ipu1-di1.dtb \
+	imx6q-sabresd-logo-lvds-ipu2-di1.dtb \
+	imx6q-sabresd-logo-hdmi-ipu1-di0.dtb \
+	imx6q-sabresd-logo-hdmi-ipu2-di0.dtb \
 	imx6sl-evk.dtb \
 	imx6sl-evk-btwifi.dtb \
 	imx6sl-evk-csi.dtb \
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-logo-hdmi-ipu1-di0.dts b/arch/arm/boot/dts/imx6dl-sabresd-logo-hdmi-ipu1-di0.dts
new file mode 100755
index 0000000..65d2758
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-logo-hdmi-ipu1-di0.dts
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6dl-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "hdmi";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-logo-lcd-ipu1-di0.dts b/arch/arm/boot/dts/imx6dl-sabresd-logo-lcd-ipu1-di0.dts
new file mode 100755
index 0000000..236bd97a
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-logo-lcd-ipu1-di0.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6dl-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "lcd";
+	interface_pix_fmt = "RGB565";
+	mode_str ="CLAA-WVGA";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&mxclcd0 {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di0.dts b/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di0.dts
new file mode 100755
index 0000000..3cc1a56
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di0.dts
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6dl-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@0 {
+		primary;
+		crtc = "ipu1-di0";
+		status = "okay";
+	};
+
+	lvds-channel@1 {
+		status = "disabled";
+	};
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di1.dts b/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di1.dts
new file mode 100755
index 0000000..e74012c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6dl-sabresd-logo-lvds-ipu1-di1.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6dl-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB666";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@1 {
+		crtc = "ipu1-di1";
+		status = "okay";
+	};
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu1-di0.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu1-di0.dts
new file mode 100755
index 0000000..a21602e
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu1-di0.dts
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "hdmi";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu2-di0.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu2-di0.dts
new file mode 100755
index 0000000..9e92395
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-hdmi-ipu2-di0.dts
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "hdmi";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <1>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu2 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-lcd-ipu1-di0.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-lcd-ipu1-di0.dts
new file mode 100755
index 0000000..429d2df
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-lcd-ipu1-di0.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "lcd";
+	interface_pix_fmt = "RGB565";
+	mode_str ="CLAA-WVGA";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&mxclcd0 {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di0.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di0.dts
new file mode 100755
index 0000000..e36ceaa
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di0.dts
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB24";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@0 {
+		primary;
+		crtc = "ipu1-di0";
+		status = "okay";
+	};
+
+	lvds-channel@1 {
+		status = "disabled";
+	};
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di1.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di1.dts
new file mode 100755
index 0000000..c8adb87
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu1-di1.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB666";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@1 {
+		crtc = "ipu1-di1";
+		status = "okay";
+	};
+};
+
+&ipu1 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu2-di1.dts b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu2-di1.dts
new file mode 100755
index 0000000..7dff781
--- /dev/null
+++ b/arch/arm/boot/dts/imx6q-sabresd-logo-lvds-ipu2-di1.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "imx6q-sabresd.dts"
+
+&mxcfb1 {
+	compatible = "fsl,mxc_sdc_fb";
+	disp_dev = "ldb";
+	interface_pix_fmt = "RGB666";
+	default_bpp = <32>;
+	int_clk = <0>;
+	late_init = <1>;
+	fb_base = <0x18800000>;  /* Frame buffer base address, it is same as CONFIG_FB_BASE in Uboot. */
+	fb_size = <0x01800000>;  /* Reserved display memory size, bigger than 3 x framer buffer size. */
+	status = "okay";
+};
+
+&ldb {
+	lvds-channel@1 {
+		crtc = "ipu2-di1";
+		status = "okay";
+	};
+};
+
+&ipu2 {
+	bypass_reset = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/imx6qdl-sabresd-070-1024600-logokeep.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd-070-1024600-logokeep.dtsi
new file mode 100755
index 0000000..c7635c4
--- /dev/null
+++ b/arch/arm/boot/dts/imx6qdl-sabresd-070-1024600-logokeep.dtsi
@@ -0,0 +1,1207 @@
+/*
+ * Copyright 2012 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/input/input.h>
+
+/ {
+	aliases {
+		mxcfb0 = &mxcfb1;
+		mxcfb1 = &mxcfb2;
+		mxcfb2 = &mxcfb3;
+		mxcfb3 = &mxcfb4;
+	};
+
+	battery: max8903@0 {
+		compatible = "fsl,max8903-charger";
+		pinctrl-names = "default";
+		dok_input = <&gpio2 24 1>;
+		uok_input = <&gpio1 27 1>;
+		/* chg_input = <&gpio3 23 1>;*/
+		/* flt_input = <&gpio5 2 1>;*/
+		fsl,dcm_always_high;
+		fsl,dc_valid;
+		fsl,usb_valid;
+		status = "okay";
+	};
+
+	hannstar_cabc {
+		compatible = "hannstar,cabc";
+
+		lvds0 {
+			gpios = <&gpio6 15 GPIO_ACTIVE_HIGH>;
+		};
+
+		lvds1 {
+			gpios = <&gpio6 16 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led4 {
+			label = "led4";
+			gpios = <&gpio3 21 0>;
+			default-state = "off";
+		};
+
+		led5 {
+			label = "led5";
+			gpios = <&gpio3 22 0>;
+			default-state = "off";
+		};
+		
+	};
+
+	memory: memory {
+		reg = <0x10000000 0x40000000>;
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_usb_otg_vbus: regulator@0 {
+			compatible = "regulator-fixed";
+			reg = <0>;
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			/* gpio = <&gpio3 22 0>; */
+			enable-active-high;
+		};
+
+		reg_usb_h1_vbus: regulator@1 {
+			compatible = "regulator-fixed";
+			reg = <1>;
+			regulator-name = "usb_h1_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			/* gpio = <&gpio1 29 0>; */
+			enable-active-high;
+		};
+
+		reg_audio: regulator@2 {
+			compatible = "regulator-fixed";
+			reg = <2>;
+			regulator-name = "sgtl5000-supply";
+			/* gpio = <&gpio4 10 0>; */
+			enable-active-high;
+		};
+
+		reg_mipi_dsi_pwr_on: mipi_dsi_pwr_on {
+			compatible = "regulator-fixed";
+			regulator-name = "mipi_dsi_pwr_on";
+			gpio = <&gpio6 14 0>;
+			enable-active-high;
+		};
+
+		reg_sensor: regulator@3 {
+			compatible = "regulator-fixed";
+			reg = <3>;
+			regulator-name = "sensor-supply";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			gpio = <&gpio2 31 0>;
+			startup-delay-us = <500>;
+			enable-active-high;
+		};
+		
+		wlreg_on: fixedregulator@100 {
+                        compatible = "regulator-fixed";
+                        regulator-min-microvolt = <5000000>;
+                        regulator-max-microvolt = <5000000>;
+                        regulator-name = "wlreg_on";
+                        /* gpio = <&gpio7 1 0>;                 LEAVS PATCHED 1 gpio = <&gpio4 7 0>; */
+                        startup-delay-us = <100>;
+                        enable-active-high;
+                };
+
+		/* LEAVS PATCHED SOUND */
+                reg_3p3v: regulator@4 {
+                        compatible = "regulator-fixed";
+                        reg = <4>;
+                        regulator-name = "3P3V";
+                        regulator-min-microvolt = <3300000>;
+                        regulator-max-microvolt = <3300000>;
+                        regulator-always-on;
+                };
+                reg_2p5v: regulator@5 {
+                        compatible = "regulator-fixed";
+                        reg = <5>;
+                        regulator-name = "2P5V";
+                        regulator-min-microvolt = <2500000>;
+                        regulator-max-microvolt = <2500000>;
+                        regulator-always-on;
+                };
+	};
+
+	sound {
+                compatible = "fsl,imx6q-sabresd-sgtl5000",
+                                "fsl,imx-audio-sgtl5000";
+                model = "imx6q-sgtl5000";
+                cpu-dai = <&ssi1>;
+                audio-codec = <&codec>;
+                audio-routing =
+                        "MIC_IN", "Mic Jack",
+                        "Mic Jack", "Mic Bias",
+                        "Headphone Jack", "HP_OUT";
+                mux-int-port = <1>;
+                mux-ext-port = <3>;
+        };
+
+	sound-hdmi {
+		compatible = "fsl,imx6q-audio-hdmi",
+			     "fsl,imx-audio-hdmi";
+		model = "imx-audio-hdmi";
+		hdmi-controller = <&hdmi_audio>;
+	};
+
+	mxcfb1: fb@0 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB24";
+		default_bpp = <32>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb2: fb@1 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "hdmi";
+		interface_pix_fmt = "RGB24";
+		mode_str ="1920x1080M@60";
+		default_bpp = <24>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb3: fb@2 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "lcd";
+		interface_pix_fmt = "RGB565";
+		mode_str ="CLAA-WVGA";
+		default_bpp = <32>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxcfb4: fb@3 {
+		compatible = "fsl,mxc_sdc_fb";
+		disp_dev = "ldb";
+		interface_pix_fmt = "RGB666";
+		default_bpp = <16>;
+		int_clk = <0>;
+		late_init = <0>;
+		status = "disabled";
+	};
+
+	mxclcd0: lcd@0 {
+		compatible = "fsl,lcd";
+		ipu_id = <0>;
+		disp_id = <0>;
+		default_ifmt = "RGB24";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1>;
+		status = "disabled";
+	};
+
+	backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm1 0 5000000>;
+		brightness-levels = <0 4 8 16 32 64 128 255>;
+		default-brightness-level = <7>;
+		status = "okay";
+	};
+
+	v4l2_cap_0 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <0>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_cap_1 {
+		compatible = "fsl,imx6q-v4l2-capture";
+		ipu_id = <0>;
+		csi_id = <1>;
+		mclk_source = <0>;
+		status = "okay";
+	};
+
+	v4l2_out {
+		compatible = "fsl,mxc_v4l2_output";
+		status = "okay";
+	};
+
+	mipi_dsi_reset: mipi-dsi-reset {
+		compatible = "gpio-reset";
+		reset-gpios = <&gpio6 11 GPIO_ACTIVE_LOW>;
+		reset-delay-us = <50>;
+		#reset-cells = <0>;
+	};
+	
+};
+
+&audmux {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_audmux>;
+	status = "okay";
+};
+
+&cpu0 {
+	/*arm-supply = <&sw1a_reg>;*/
+	/*soc-supply = <&sw1c_reg>;*/
+};
+
+&clks {
+	fsl,ldb-di0-parent = <&clks IMX6QDL_CLK_PLL2_PFD0_352M>;
+	fsl,ldb-di1-parent = <&clks IMX6QDL_CLK_PLL2_PFD0_352M>;
+};
+
+&ecspi1 {
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio4 9 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi1>;
+	status = "disable";     /* leavs patched for enable uart5 */
+
+	flash: m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "st,m25p32";
+		spi-max-frequency = <20000000>;
+		reg = <0>;
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet>;
+	phy-mode = "rgmii";
+	/* leavs patched for uart2 phy-reset-gpios = <&gpio1 25 0>; */
+	fsl,magic-packet;
+	status = "okay";
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+	
+	mma8451@1c {
+		compatible = "fsl,mma8451";
+		reg = <0x1c>;
+		position = <0>;
+		vdd-supply = <&reg_sensor>;
+		vddio-supply = <&reg_sensor>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <18 8>;
+		interrupt-route = <1>;
+	};
+
+	ft5x06@38 {
+		compatible = "ft5x06,ft5x06-touch";
+		reg = <0x38>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <9 2>;
+		wakeup-gpios = <&gpio1 9 1>;
+	};
+
+	ds1307@32 {
+		compatible = "dallas,rx8025";
+		reg = <0x32>;
+	};	
+
+	ov564x: ov564x@3c {
+		compatible = "ovti,ov564x";
+		reg = <0x3c>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_ipu1_2>;
+		clocks = <&clks IMX6QDL_CLK_CKO>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&vgen4_reg>; /* 1.8v */
+		AVDD-supply = <&vgen3_reg>;  /* 2.8v, on rev C board is VGEN3,
+						on rev B board is VGEN5 */
+		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
+		/* pwn-gpios = <&gpio1 16 1>;   active low: SD1_DAT0 */
+		rst-gpios = <&gpio1 17 0>;   /* active high: SD1_DAT1 */
+		csi_id = <0>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+
+	hdmi: edid@50 {
+		compatible = "fsl,imx6-hdmi-i2c";
+		reg = <0x50>;
+	};
+
+        codec: sgtl5000@0a {
+                compatible = "fsl,sgtl5000";
+                reg = <0x0a>;
+                clocks = <&clks 201>;
+                VDDA-supply = <&reg_3p3v>;
+                VDDIO-supply = <&reg_3p3v>;
+        };
+
+	pmic: pfuze100@08 {
+		compatible = "fsl,pfuze100";
+		reg = <0x08>;
+
+		regulators {
+			sw1a_reg: sw1ab {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw1c_reg: sw1c {
+				regulator-min-microvolt = <300000>;
+				regulator-max-microvolt = <1875000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw2_reg: sw2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <6250>;
+			};
+
+			sw3a_reg: sw3a {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw3b_reg: sw3b {
+				regulator-min-microvolt = <400000>;
+				regulator-max-microvolt = <1975000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			sw4_reg: sw4 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			swbst_reg: swbst {
+				regulator-min-microvolt = <5000000>;
+				regulator-max-microvolt = <5150000>;
+			};
+
+			snvs_reg: vsnvs {
+				regulator-min-microvolt = <1000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vref_reg: vrefddr {
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vgen1_reg: vgen1 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen2_reg: vgen2 {
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1550000>;
+			};
+
+			vgen3_reg: vgen3 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+
+			vgen4_reg: vgen4 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen5_reg: vgen5 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+
+			vgen6_reg: vgen6 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+			};
+		};
+	};
+
+	ov564x_mipi: ov564x_mipi@3c { /* i2c2 driver */
+		compatible = "ovti,ov564x_mipi";
+		reg = <0x3c>;
+		clocks = <&clks 201>;
+		clock-names = "csi_mclk";
+		DOVDD-supply = <&vgen4_reg>; /* 1.8v */
+		AVDD-supply = <&vgen3_reg>;  /* 2.8v, rev C board is VGEN3
+						rev B board is VGEN5 */
+		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
+		pwn-gpios = <&gpio1 19 1>;   /* active low: SD1_CLK */
+		rst-gpios = <&gpio1 20 0>;   /* active high: SD1_DAT2 */
+		csi_id = <1>;
+		mclk = <24000000>;
+		mclk_source = <0>;
+	};
+
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	mag3110@0e {
+		compatible = "fsl,mag3110";
+		reg = <0x0e>;
+		position = <2>;
+		vdd-supply = <&reg_sensor>;
+		vddio-supply = <&reg_sensor>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <16 1>;
+	};
+
+	isl29023@44 {
+		compatible = "fsl,isl29023";
+		reg = <0x44>;
+		rext = <499>;
+		vdd-supply = <&reg_sensor>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <9 2>;
+	};
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hog>;
+
+	imx6qdl-sabresd {
+		pinctrl_hog: hoggrp {
+			fsl,pins = <
+				MX6QDL_PAD_NANDF_D0__GPIO2_IO00 0x80000000
+				MX6QDL_PAD_NANDF_D1__GPIO2_IO01 0x80000000
+				MX6QDL_PAD_NANDF_D2__GPIO2_IO02 0x80000000
+				MX6QDL_PAD_NANDF_D3__GPIO2_IO03 0x80000000
+				/* LEAVS PATCHED SOUND MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x130b0 */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x80000000
+				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07 0x80000000
+				MX6QDL_PAD_NANDF_ALE__GPIO6_IO08 0x80000000
+				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_EIM_D21__GPIO3_IO21  0x80000000
+				MX6QDL_PAD_EIM_D16__GPIO3_IO16  0x80000000
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31 0x80000000
+				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25 0x80000000
+				/* leavs patched for uart2 MX6QDL_PAD_EIM_D26__GPIO3_IO26 0x80000000 */
+				MX6QDL_PAD_EIM_CS1__GPIO2_IO24 0x80000000
+				MX6QDL_PAD_ENET_RXD0__GPIO1_IO27 0x80000000
+				MX6QDL_PAD_EIM_EB3__GPIO2_IO31 0x80000000
+				/* leavs patched for enable pwm4 MX6QDL_PAD_SD1_CMD__GPIO1_IO18 0x80000000 */
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08	0x1b0b0
+				MX6QDL_PAD_GPIO_9__GPIO1_IO09 	0x80000000
+				MX6QDL_PAD_EIM_DA9__GPIO3_IO09 0x80000000
+				MX6QDL_PAD_GPIO_1__WDOG2_B 0x80000000
+				/* MX6QDL_PAD_GPIO_2__GPIO1_IO02 0x1b0b0 */
+				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11 0x80000000
+				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14 0x80000000
+				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15 0x80000000
+				MX6QDL_PAD_NANDF_CS3__GPIO6_IO16 0x80000000
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01 0x80000000
+                                MX6QDL_PAD_SD3_DAT5__GPIO7_IO00 0x80000000
+                                MX6QDL_PAD_SD1_DAT0__GPIO1_IO16 0x80000000      /* leavs patched for enable lvds power */
+                                MX6QDL_PAD_GPIO_19__GPIO4_IO05 0X80000000       /* leavs add for ADXL345 */
+                                MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28 0X80000000    /*leavs add for LCD cap touch screen and GPIO1_28*/
+                                MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000     /* GPIO1_29 */
+                                MX6QDL_PAD_ENET_TXD0__GPIO1_IO30 0X80000000     /* GPIO1_30 */
+                                MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000       /* GPIO3_23 */
+                                MX6QDL_PAD_EIM_D30__GPIO3_IO30  0x80000000      /* GPIO3_30 */
+                                MX6QDL_PAD_EIM_D31__GPIO3_IO31  0X80000000      /* GPIO3_31 */
+                                MX6QDL_PAD_KEY_COL2__GPIO4_IO10 0X80000000      /* GPIO4_10 */
+                                MX6QDL_PAD_EIM_A25__GPIO5_IO02  0X80000000      /* GPIO5_2 */
+			>;
+		};
+
+		pinctrl_audmux: audmuxgrp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD		0x130b0
+				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC		0x130b0
+				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD		0x110b0
+				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS		0x130b0
+			>;
+		};
+
+		pinctrl_ecspi1: ecspi1grp {
+			fsl,pins = <
+				/*MX6QDL_PAD_KEY_COL1__ECSPI1_MISO	0x100b1*/
+				/*MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI	0x100b1*/
+				/*MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK	0x100b1*/
+			>;
+		};
+
+		pinctrl_enet: enetgrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_MDIO__ENET_MDIO		0x1b0b0
+				MX6QDL_PAD_ENET_MDC__ENET_MDC		0x1b0b0
+				MX6QDL_PAD_RGMII_TXC__RGMII_TXC		0x1b0b0
+				MX6QDL_PAD_RGMII_TD0__RGMII_TD0		0x1b0b0
+				MX6QDL_PAD_RGMII_TD1__RGMII_TD1		0x1b0b0
+				MX6QDL_PAD_RGMII_TD2__RGMII_TD2		0x1b0b0
+				MX6QDL_PAD_RGMII_TD3__RGMII_TD3		0x1b0b0
+				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL	0x1b0b0
+				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK	0x1b0b0
+				MX6QDL_PAD_RGMII_RXC__RGMII_RXC		0x1b0b0
+				MX6QDL_PAD_RGMII_RD0__RGMII_RD0		0x1b0b0
+				MX6QDL_PAD_RGMII_RD1__RGMII_RD1		0x1b0b0
+				MX6QDL_PAD_RGMII_RD2__RGMII_RD2		0x1b0b0
+				MX6QDL_PAD_RGMII_RD3__RGMII_RD3		0x1b0b0
+				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL	0x1b0b0
+				MX6QDL_PAD_GPIO_16__ENET_REF_CLK	0x4001b0a8
+			>;
+		};
+
+		pinctrl_enet_irq: enetirqgrp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_6__ENET_IRQ		0x000b1
+			>;
+		};
+
+		pinctrl_flexcan1: flexcan1grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_7__FLEXCAN1_TX        0x80000000
+                                MX6QDL_PAD_GPIO_8__FLEXCAN1_RX        0x80000000
+                        >;
+                };
+
+                pinctrl_flexcan2: flexcan2grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX        0x80000000
+                                MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX        0x80000000
+                        >;
+                };
+
+		pinctrl_gpio_keys: gpio_keysgrp {
+			fsl,pins = <
+				MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
+				MX6QDL_PAD_GPIO_4__GPIO1_IO04  0x80000000
+				MX6QDL_PAD_GPIO_5__GPIO1_IO05  0x80000000
+			>;
+		};
+
+		pinctrl_hdmi_cec: hdmicecgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW2__HDMI_TX_CEC_LINE 0x1f8b0
+			>;
+		};
+
+		pinctrl_hdmi_hdcp: hdmihdcpgrp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c1: i2c1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA		0x4001b8b1
+				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL		0x4001b8b1
+			>;
+		};
+
+		pinctrl_i2c2: i2c2grp {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL3__I2C2_SCL		0x4001b8b1
+				MX6QDL_PAD_KEY_ROW3__I2C2_SDA		0x4001b8b1
+			 >;
+		};
+
+		pinctrl_i2c3: i2c3grp {
+			fsl,pins = <
+				MX6QDL_PAD_GPIO_3__I2C3_SCL		0x4001b8b1
+				MX6QDL_PAD_GPIO_6__I2C3_SDA		0x4001b8b1
+			>;
+		};
+
+		pinctrl_ipu1: ipu1grp {
+			fsl,pins = <
+				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x10
+				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15       0x10
+				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02        0x10
+				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03        0x10
+				MX6QDL_PAD_DI0_PIN4__IPU1_DI0_PIN04        0x80000000
+				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00   0x10
+				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01   0x10
+				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02   0x10
+				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03   0x10
+				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04   0x10
+				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05   0x10
+				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06   0x10
+				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07   0x10
+				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08   0x10
+				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09   0x10
+				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10  0x10
+				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11  0x10
+				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12  0x10
+				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13  0x10
+				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14  0x10
+				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15  0x10
+				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16  0x10
+				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17  0x10
+				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18  0x10
+				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19  0x10
+				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20  0x10
+				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21  0x10
+				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22  0x10
+				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23  0x10
+			>;
+		};
+
+		pinctrl_ipu1_2: ipu1grp-2 { /* parallel camera */
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT12__IPU1_CSI0_DATA12    0x80000000
+				MX6QDL_PAD_CSI0_DAT13__IPU1_CSI0_DATA13    0x80000000
+				MX6QDL_PAD_CSI0_DAT14__IPU1_CSI0_DATA14    0x80000000
+				MX6QDL_PAD_CSI0_DAT15__IPU1_CSI0_DATA15    0x80000000
+				MX6QDL_PAD_CSI0_DAT16__IPU1_CSI0_DATA16    0x80000000
+				MX6QDL_PAD_CSI0_DAT17__IPU1_CSI0_DATA17    0x80000000
+				MX6QDL_PAD_CSI0_DAT18__IPU1_CSI0_DATA18    0x80000000
+				MX6QDL_PAD_CSI0_DAT19__IPU1_CSI0_DATA19    0x80000000
+				MX6QDL_PAD_CSI0_DATA_EN__IPU1_CSI0_DATA_EN 0x80000000
+				MX6QDL_PAD_CSI0_PIXCLK__IPU1_CSI0_PIXCLK   0x80000000
+				MX6QDL_PAD_CSI0_MCLK__IPU1_CSI0_HSYNC      0x80000000
+				MX6QDL_PAD_CSI0_VSYNC__IPU1_CSI0_VSYNC     0x80000000
+			>;
+		};
+
+		pinctrl_pwm1: pwm1grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD1_DAT3__PWM1_OUT		0x1b0b1
+			>;
+		};
+
+		pinctrl_pwm4: pwm4grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD1_CMD__PWM4_OUT            0x1b0b1
+                        >;
+                };
+
+		pinctrl_uart1: uart1grp {
+			fsl,pins = <
+				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart1_2: uart1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT7__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_DAT6__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2_1: uart2grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D26__UART2_TX_DATA       0x1b0b1
+                                MX6QDL_PAD_EIM_D27__UART2_RX_DATA       0x1b0b1
+                                MX6QDL_PAD_EIM_D28__UART2_CTS_B         0x1b0b1
+                                MX6QDL_PAD_EIM_D29__UART2_RTS_B         0x1b0b1
+                        >;
+                };
+
+		pinctrl_uart3_1: uart3grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D24__UART3_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_EIM_D25__UART3_RX_DATA      0x1b0b1
+                        >;
+                };
+
+                pinctrl_uart4_1: uart4grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL0__UART4_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA      0x1b0b1
+                        >;
+                };
+
+		pinctrl_uart5_1: uart5grp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_COL1__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_KEY_ROW1__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_KEY_COL4__UART5_RTS_B	0x1b0b1
+				MX6QDL_PAD_KEY_ROW4__UART5_CTS_B	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart5_2: uart5grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL1__UART5_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_KEY_ROW1__UART5_RX_DATA      0x1b0b1
+                        >;
+                };
+
+		pinctrl_uart5dte_1: uart5dtegrp-1 {
+			fsl,pins = <
+				MX6QDL_PAD_KEY_ROW1__UART5_TX_DATA	0x1b0b1
+				MX6QDL_PAD_KEY_COL1__UART5_RX_DATA	0x1b0b1
+				MX6QDL_PAD_KEY_ROW4__UART5_RTS_B	0x1b0b1
+				MX6QDL_PAD_KEY_COL4__UART5_CTS_B	0x1b0b1
+			>;
+		};
+
+		pinctrl_usbotg: usbotggrp {
+			fsl,pins = <
+				MX6QDL_PAD_ENET_RX_ER__USB_OTG_ID	0x17059
+			>;
+		};
+
+		pinctrl_usdhc2: usdhc2grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17059
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10059
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17059
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17059
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17059
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17059
+				MX6QDL_PAD_NANDF_D4__SD2_DATA4		0x17059
+				MX6QDL_PAD_NANDF_D5__SD2_DATA5		0x17059
+				MX6QDL_PAD_NANDF_D6__SD2_DATA6		0x17059
+				MX6QDL_PAD_NANDF_D7__SD2_DATA7		0x17059
+			>;
+		};
+
+		pinctrl_usdhc2_2: usdhc2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17079
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10079
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17079
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17079
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17079
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17079
+			>;
+		};
+
+		pinctrl_usdhc3: usdhc3grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
+				MX6QDL_PAD_SD3_DAT4__SD3_DATA4		0x17059
+				MX6QDL_PAD_SD3_DAT5__SD3_DATA5		0x17059
+				MX6QDL_PAD_SD3_DAT6__SD3_DATA6		0x17059
+				MX6QDL_PAD_SD3_DAT7__SD3_DATA7		0x17059
+			>;
+		};
+
+		pinctrl_usdhc3_2: usdhc3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
+			>;
+		};
+
+		pinctrl_usdhc4: usdhc4grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD4_CMD__SD4_CMD		0x17059
+				MX6QDL_PAD_SD4_CLK__SD4_CLK		0x10059
+				MX6QDL_PAD_SD4_DAT0__SD4_DATA0		0x17059
+				MX6QDL_PAD_SD4_DAT1__SD4_DATA1		0x17059
+				MX6QDL_PAD_SD4_DAT2__SD4_DATA2		0x17059
+				MX6QDL_PAD_SD4_DAT3__SD4_DATA3		0x17059
+				MX6QDL_PAD_SD4_DAT4__SD4_DATA4		0x17059
+				MX6QDL_PAD_SD4_DAT5__SD4_DATA5		0x17059
+				MX6QDL_PAD_SD4_DAT6__SD4_DATA6		0x17059
+				MX6QDL_PAD_SD4_DAT7__SD4_DATA7		0x17059
+			>;
+		};
+
+	};
+};
+
+&dcic1 {
+	dcic_id = <0>;
+	dcic_mux = "dcic-hdmi";
+	status = "okay";
+};
+
+&dcic2 {
+	dcic_id = <1>;
+	dcic_mux = "dcic-lvds1";
+	status = "okay";
+};
+
+&flexcan1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_flexcan1>;
+        /* pinctrl-assert-gpios = <&max7310_b 3 GPIO_ACTIVE_HIGH>; TX */
+        /* trx-en-gpio = <&max7310_b 6 GPIO_ACTIVE_HIGH>;*/
+        /* trx-stby-gpio = <&max7310_b 5 GPIO_ACTIVE_HIGH>;*/
+        status = "okay";
+};
+
+&flexcan2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_flexcan2>;
+        /*trx-en-gpio = <&max7310_c 6 GPIO_ACTIVE_HIGH>;*/
+        /*trx-stby-gpio = <&max7310_c 5 GPIO_ACTIVE_HIGH>;*/
+        status = "okay";
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	power-en-gpio = <&gpio1 16 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&gpc {
+	/* use ldo-bypass, u-boot will check it and configure */
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_cec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_hdmi_cec>;
+	status = "okay";
+};
+
+&hdmi_core {
+	ipu_id = <0>;
+	disp_id = <0>;
+	status = "okay";
+};
+
+&hdmi_video {
+	fsl,phy_reg_vlev = <0x0294>;
+	fsl,phy_reg_cksymtx = <0x800d>;
+	status = "okay";
+};
+
+&ldb {
+	status = "okay";
+	/*split-mode;*/
+
+	lvds-channel@0 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		primary;
+		status = "okay";
+		
+		display-timings {
+			native-mode = <&timing010>;
+			timing07: IONOLUX-WSVGA {
+                                clock-frequency = <51200000>;
+                                hactive = <1024>;
+                                vactive = <600>;
+                                hback-porch = <40>;
+                                hfront-porch = <220>;
+                                vback-porch = <5>;
+                                vfront-porch = <20>;
+                                hsync-len = <60>;
+                                vsync-len = <10>;
+                        };
+			timing010: CHIMEI-WXGA {
+				clock-frequency = <71100000>;
+				hactive = <1280>;
+				vactive = <800>;
+				hback-porch = <40>;
+				hfront-porch = <40>;
+				vback-porch = <3>;
+				vfront-porch = <10>;
+				hsync-len = <80>;
+				vsync-len = <10>;
+			};
+			timing028: BOE28 {
+                                clock-frequency = <148500000>;
+                                hactive = <1920>;
+                                vactive = <360>;
+                                hback-porch = <139>;
+                                hfront-porch = <139>;
+                                vback-porch = <14>;
+                                vfront-porch = <14>;
+                                hsync-len = <2>;
+                                vsync-len = <2>;
+                        };
+                        timing019: CHIMEI-WXGA+ {
+                                clock-frequency = <88800000>;
+                                hactive = <1440>;
+                                vactive = <900>;
+                                hback-porch = <60>;
+                                hfront-porch = <60>;
+                                vback-porch = <20>;
+                                vfront-porch = <20>;
+                                hsync-len = <40>;
+                                vsync-len = <12>;
+                        };
+                        timing0215: CHIMEI-AUO215 {
+                                clock-frequency = <148640000>;
+                                hactive = <1920>;
+                                vactive = <1080>;
+                                hback-porch = <100>;
+                                hfront-porch = <100>;
+                                vback-porch = <40>;
+                                vfront-porch = <40>;
+                                hsync-len = <80>;
+                                vsync-len = <10>;
+                        };
+                        timing012: IVO-VGA121 {                 /* 12 and 15 use the same timing  */
+                                clock-frequency = <65000000>;
+                                hactive = <1024>;
+                                vactive = <768>;
+                                hback-porch = <48>;
+                                hfront-porch = <240>;
+                                vback-porch = <23>;
+                                vfront-porch = <3>;
+                                hsync-len = <32>;
+                                vsync-len = <12>;
+                        };
+			timing0170: AUO170 {
+				clock-frequency = <108000000>;
+				hactive = <1280>;
+				vactive = <1024>;
+				hback-porch = <150>;
+				hfront-porch = <150>;
+				vback-porch = <40>;
+				vfront-porch = <40>;
+				hsync-len = <108>;
+				vsync-len = <4>;
+			};
+		};
+	};
+
+	lvds-channel@1 {
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
+		status = "okay";
+
+		display-timings {
+			native-mode = <&timing128>;
+			timing128: BOE28 {
+                                clock-frequency = <148500000>;
+                                hactive = <1920>;
+                                vactive = <360>;
+                                hback-porch = <139>;
+                                hfront-porch = <139>;
+                                vback-porch = <14>;
+                                vfront-porch = <14>;
+                                hsync-len = <2>;
+                                vsync-len = <2>;
+                        };
+                        timing119: CHIMEI-WXGA+ {
+                                clock-frequency = <88800000>;
+                                hactive = <1440>;
+                                vactive = <900>;
+                                hback-porch = <60>;
+                                hfront-porch = <60>;
+                                vback-porch = <20>;
+                                vfront-porch = <20>;
+                                hsync-len = <40>;
+                                vsync-len = <12>;
+                        };
+                        timing1215: CHIMEI-AUO215 {
+                                clock-frequency = <148640000>;
+                                hactive = <1920>;
+                                vactive = <1080>;
+                                hback-porch = <100>;
+                                hfront-porch = <100>;
+                                vback-porch = <40>;
+                                vfront-porch = <40>;
+                                hsync-len = <80>;
+                                vsync-len = <10>;
+                        };
+			timing1170: AUO170 {
+				clock-frequency = <108000000>;
+				hactive = <1280>;
+				vactive = <1024>;
+				hback-porch = <150>;
+				hfront-porch = <150>;
+				vback-porch = <40>;
+				vfront-porch = <40>;
+				hsync-len = <108>;
+				vsync-len = <4>;
+			};
+		};
+	};
+};
+
+&mipi_csi {
+	status = "okay";
+	ipu_id = <0>;
+	csi_id = <1>;
+	v_channel = <0>;
+	lanes = <2>;
+};
+
+&mipi_dsi {
+	dev_id = <0>;
+	disp_id = <1>;
+	lcd_panel = "TRULY-WVGA";
+	disp-power-on-supply = <&reg_mipi_dsi_pwr_on>;
+	resets = <&mipi_dsi_reset>;
+	status = "okay";
+};
+
+&pcie {
+	power-on-gpio = <&gpio3 19 0>;
+	reset-gpio = <&gpio7 12 0>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "okay";
+};
+
+&pwm4 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm4>;
+        status = "disable";
+};
+
+&ssi1 {
+        fsl,mode = "i2s-slave";
+        status = "okay";
+};
+
+&ssi2 {
+	fsl,mode = "i2s-slave";
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1_2>;
+	status = "okay";
+};
+
+&uart2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_uart2_1>;
+        fsl,uart-has-rtscts;
+        status = "okay";
+};
+
+&uart3 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart3_1>;
+    status = "okay";
+};
+
+&uart4 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart4_1>;
+    status = "okay";
+};
+
+&uart5 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart5_2>;
+    status = "okay";
+};
+
+&usbh1 {
+	status = "okay";
+};
+
+&usbotg {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usbotg>;
+	disable-over-current;
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	status = "okay";
+};
+
+&usdhc2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usdhc2_2>;
+        bus-width = <8>;        /* LEAVS PATCHED 2 bus-width = <4>; */
+        cd-gpios = <&gpio1 4 0>;
+        /* LEAVS PATCHED 1 wifi-host; */
+        no-1-8-v;
+        /* LEAVS PATCHED 2 pm-ignore-notify; */
+        keep-power-in-suspend;
+        enable-sdio-wakeup;
+        status = "okay";
+};
+
+&usdhc3 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usdhc3_2>;
+        bus-width = <4>;                        /* LEAVS PATCHED 2 bus-width = <8>; */
+        /* LEAVS PATCHED 1 cd-gpios = <&gpio2 0 0>;     */
+        /* LEAVS PATCHED 1 wp-gpios = <&gpio2 1 0>; */
+        wifi-host;                                      /* LEAVS PATCHED 1 */
+        no-1-8-v;
+        pm-ignore-notify;                       /* LEAVS PATCHED 2 */
+        keep-power-in-suspend;
+        enable-sdio-wakeup;
+        /*vmmc-supply = <&wlreg_on>;*/
+        status = "okay";
+};
+
+&usdhc4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc4>;
+	bus-width = <8>;
+	non-removable;
+	no-1-8-v;
+	keep-power-in-suspend;
+	status = "okay";
+};
+
+&wdog1 {
+	status = "disabled";
+};
+
+&wdog2 {
+	status = "okay";
+};
diff --git a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
index 2d2e483..c7635c4 100644
--- a/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
+++ b/arch/arm/boot/dts/imx6qdl-sabresd.dtsi
@@ -25,8 +25,8 @@
 		pinctrl-names = "default";
 		dok_input = <&gpio2 24 1>;
 		uok_input = <&gpio1 27 1>;
-		chg_input = <&gpio3 23 1>;
-		flt_input = <&gpio5 2 1>;
+		/* chg_input = <&gpio3 23 1>;*/
+		/* flt_input = <&gpio5 2 1>;*/
 		fsl,dcm_always_high;
 		fsl,dc_valid;
 		fsl,usb_valid;
@@ -48,11 +48,18 @@
 	leds {
 		compatible = "gpio-leds";
 
-		charger-led {
-			gpios = <&gpio1 2 0>;
-			linux,default-trigger = "max8903-charger-charging";
-			retain-state-suspended;
+		led4 {
+			label = "led4";
+			gpios = <&gpio3 21 0>;
+			default-state = "off";
 		};
+
+		led5 {
+			label = "led5";
+			gpios = <&gpio3 22 0>;
+			default-state = "off";
+		};
+		
 	};
 
 	memory: memory {
@@ -70,7 +77,7 @@
 			regulator-name = "usb_otg_vbus";
 			regulator-min-microvolt = <5000000>;
 			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio3 22 0>;
+			/* gpio = <&gpio3 22 0>; */
 			enable-active-high;
 		};
 
@@ -80,15 +87,15 @@
 			regulator-name = "usb_h1_vbus";
 			regulator-min-microvolt = <5000000>;
 			regulator-max-microvolt = <5000000>;
-			gpio = <&gpio1 29 0>;
+			/* gpio = <&gpio1 29 0>; */
 			enable-active-high;
 		};
 
 		reg_audio: regulator@2 {
 			compatible = "regulator-fixed";
 			reg = <2>;
-			regulator-name = "wm8962-supply";
-			gpio = <&gpio4 10 0>;
+			regulator-name = "sgtl5000-supply";
+			/* gpio = <&gpio4 10 0>; */
 			enable-active-high;
 		};
 
@@ -109,60 +116,49 @@
 			startup-delay-us = <500>;
 			enable-active-high;
 		};
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_gpio_keys>;
-
-		power {
-			label = "Power Button";
-			gpios = <&gpio3 29 1>;
-			gpio-key,wakeup;
-			linux,code = <KEY_POWER>;
-		};
-
-		volume-up {
-			label = "Volume Up";
-			gpios = <&gpio1 4 1>;
-			gpio-key,wakeup;
-			linux,code = <KEY_VOLUMEUP>;
-		};
-
-		volume-down {
-			label = "Volume Down";
-			gpios = <&gpio1 5 1>;
-			gpio-key,wakeup;
-			linux,code = <KEY_VOLUMEDOWN>;
-		};
+		
+		wlreg_on: fixedregulator@100 {
+                        compatible = "regulator-fixed";
+                        regulator-min-microvolt = <5000000>;
+                        regulator-max-microvolt = <5000000>;
+                        regulator-name = "wlreg_on";
+                        /* gpio = <&gpio7 1 0>;                 LEAVS PATCHED 1 gpio = <&gpio4 7 0>; */
+                        startup-delay-us = <100>;
+                        enable-active-high;
+                };
+
+		/* LEAVS PATCHED SOUND */
+                reg_3p3v: regulator@4 {
+                        compatible = "regulator-fixed";
+                        reg = <4>;
+                        regulator-name = "3P3V";
+                        regulator-min-microvolt = <3300000>;
+                        regulator-max-microvolt = <3300000>;
+                        regulator-always-on;
+                };
+                reg_2p5v: regulator@5 {
+                        compatible = "regulator-fixed";
+                        reg = <5>;
+                        regulator-name = "2P5V";
+                        regulator-min-microvolt = <2500000>;
+                        regulator-max-microvolt = <2500000>;
+                        regulator-always-on;
+                };
 	};
 
 	sound {
-		compatible = "fsl,imx6q-sabresd-wm8962",
-			   "fsl,imx-audio-wm8962";
-		model = "wm8962-audio";
-		cpu-dai = <&ssi2>;
-		audio-codec = <&codec>;
-		asrc-controller = <&asrc>;
-		audio-routing =
-			"Headphone Jack", "HPOUTL",
-			"Headphone Jack", "HPOUTR",
-			"Ext Spk", "SPKOUTL",
-			"Ext Spk", "SPKOUTR",
-			"MICBIAS", "AMIC",
-			"IN3R", "MICBIAS",
-			"DMIC", "MICBIAS",
-			"DMICDAT", "DMIC",
-			"CPU-Playback", "ASRC-Playback",
-			"Playback", "CPU-Playback",
-			"ASRC-Capture", "CPU-Capture",
-			"CPU-Capture", "Capture";
-		mux-int-port = <2>;
-		mux-ext-port = <3>;
-		hp-det-gpios = <&gpio7 8 1>;
-		mic-det-gpios = <&gpio1 9 1>;
-	};
+                compatible = "fsl,imx6q-sabresd-sgtl5000",
+                                "fsl,imx-audio-sgtl5000";
+                model = "imx6q-sgtl5000";
+                cpu-dai = <&ssi1>;
+                audio-codec = <&codec>;
+                audio-routing =
+                        "MIC_IN", "Mic Jack",
+                        "Mic Jack", "Mic Bias",
+                        "Headphone Jack", "HP_OUT";
+                mux-int-port = <1>;
+                mux-ext-port = <3>;
+        };
 
 	sound-hdmi {
 		compatible = "fsl,imx6q-audio-hdmi",
@@ -174,8 +170,8 @@
 	mxcfb1: fb@0 {
 		compatible = "fsl,mxc_sdc_fb";
 		disp_dev = "ldb";
-		interface_pix_fmt = "RGB666";
-		default_bpp = <16>;
+		interface_pix_fmt = "RGB24";
+		default_bpp = <32>;
 		int_clk = <0>;
 		late_init = <0>;
 		status = "disabled";
@@ -197,7 +193,7 @@
 		disp_dev = "lcd";
 		interface_pix_fmt = "RGB565";
 		mode_str ="CLAA-WVGA";
-		default_bpp = <16>;
+		default_bpp = <32>;
 		int_clk = <0>;
 		late_init = <0>;
 		status = "disabled";
@@ -213,14 +209,14 @@
 		status = "disabled";
 	};
 
-	lcd@0 {
+	mxclcd0: lcd@0 {
 		compatible = "fsl,lcd";
 		ipu_id = <0>;
 		disp_id = <0>;
-		default_ifmt = "RGB565";
+		default_ifmt = "RGB24";
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_ipu1>;
-		status = "okay";
+		status = "disabled";
 	};
 
 	backlight {
@@ -258,6 +254,7 @@
 		reset-delay-us = <50>;
 		#reset-cells = <0>;
 	};
+	
 };
 
 &audmux {
@@ -267,8 +264,8 @@
 };
 
 &cpu0 {
-	arm-supply = <&sw1a_reg>;
-	soc-supply = <&sw1c_reg>;
+	/*arm-supply = <&sw1a_reg>;*/
+	/*soc-supply = <&sw1c_reg>;*/
 };
 
 &clks {
@@ -281,7 +278,7 @@
 	cs-gpios = <&gpio4 9 0>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_ecspi1>;
-	status = "okay";
+	status = "disable";     /* leavs patched for enable uart5 */
 
 	flash: m25p80@0 {
 		#address-cells = <1>;
@@ -296,7 +293,7 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_enet>;
 	phy-mode = "rgmii";
-	phy-reset-gpios = <&gpio1 25 0>;
+	/* leavs patched for uart2 phy-reset-gpios = <&gpio1 25 0>; */
 	fsl,magic-packet;
 	status = "okay";
 };
@@ -306,30 +303,7 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c1>;
 	status = "okay";
-
-	codec: wm8962@1a {
-		compatible = "wlf,wm8962";
-		reg = <0x1a>;
-		clocks = <&clks 201>;
-		DCVDD-supply = <&reg_audio>;
-		DBVDD-supply = <&reg_audio>;
-		AVDD-supply = <&reg_audio>;
-		CPVDD-supply = <&reg_audio>;
-		MICVDD-supply = <&reg_audio>;
-		PLLVDD-supply = <&reg_audio>;
-		SPKVDD1-supply = <&reg_audio>;
-		SPKVDD2-supply = <&reg_audio>;
-		amic-mono;
-		gpio-cfg = <
-			0x0000 /* 0:Default */
-			0x0000 /* 1:Default */
-			0x0013 /* 2:FN_DMICCLK */
-			0x0000 /* 3:Default */
-			0x8014 /* 4:FN_DMICCDAT */
-			0x0000 /* 5:Default */
-		>;
-       };
-
+	
 	mma8451@1c {
 		compatible = "fsl,mma8451";
 		reg = <0x1c>;
@@ -341,6 +315,19 @@
 		interrupt-route = <1>;
 	};
 
+	ft5x06@38 {
+		compatible = "ft5x06,ft5x06-touch";
+		reg = <0x38>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <9 2>;
+		wakeup-gpios = <&gpio1 9 1>;
+	};
+
+	ds1307@32 {
+		compatible = "dallas,rx8025";
+		reg = <0x32>;
+	};	
+
 	ov564x: ov564x@3c {
 		compatible = "ovti,ov564x";
 		reg = <0x3c>;
@@ -352,7 +339,7 @@
 		AVDD-supply = <&vgen3_reg>;  /* 2.8v, on rev C board is VGEN3,
 						on rev B board is VGEN5 */
 		DVDD-supply = <&vgen2_reg>;  /* 1.5v*/
-		pwn-gpios = <&gpio1 16 1>;   /* active low: SD1_DAT0 */
+		/* pwn-gpios = <&gpio1 16 1>;   active low: SD1_DAT0 */
 		rst-gpios = <&gpio1 17 0>;   /* active high: SD1_DAT1 */
 		csi_id = <0>;
 		mclk = <24000000>;
@@ -371,13 +358,13 @@
 		reg = <0x50>;
 	};
 
-	max11801@48 {
-		compatible = "maxim,max11801";
-		reg = <0x48>;
-		interrupt-parent = <&gpio3>;
-		interrupts = <26 2>;
-		work-mode = <1>;/*DCM mode*/
-	};
+        codec: sgtl5000@0a {
+                compatible = "fsl,sgtl5000";
+                reg = <0x0a>;
+                clocks = <&clks 201>;
+                VDDA-supply = <&reg_3p3v>;
+                VDDIO-supply = <&reg_3p3v>;
+        };
 
 	pmic: pfuze100@08 {
 		compatible = "fsl,pfuze100";
@@ -495,14 +482,6 @@
 		mclk_source = <0>;
 	};
 
-	egalax_ts@04 {
-		compatible = "eeti,egalax_ts";
-		reg = <0x04>;
-		interrupt-parent = <&gpio6>;
-		interrupts = <8 2>;
-		wakeup-gpios = <&gpio6 8 0>;
-	};
-
 };
 
 &i2c3 {
@@ -511,14 +490,6 @@
 	pinctrl-0 = <&pinctrl_i2c3>;
 	status = "okay";
 
-	egalax_ts@04 {
-		compatible = "eeti,egalax_ts";
-		reg = <0x04>;
-		interrupt-parent = <&gpio6>;
-		interrupts = <7 2>;
-		wakeup-gpios = <&gpio6 7 0>;
-	};
-
 	mag3110@0e {
 		compatible = "fsl,mag3110";
 		reg = <0x0e>;
@@ -550,28 +521,41 @@
 				MX6QDL_PAD_NANDF_D1__GPIO2_IO01 0x80000000
 				MX6QDL_PAD_NANDF_D2__GPIO2_IO02 0x80000000
 				MX6QDL_PAD_NANDF_D3__GPIO2_IO03 0x80000000
-				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x130b0
+				/* LEAVS PATCHED SOUND MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x130b0 */
+				MX6QDL_PAD_GPIO_0__CCM_CLKO1    0x80000000
 				MX6QDL_PAD_NANDF_CLE__GPIO6_IO07 0x80000000
 				MX6QDL_PAD_NANDF_ALE__GPIO6_IO08 0x80000000
-				MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000
 				MX6QDL_PAD_EIM_D22__GPIO3_IO22  0x80000000
+				MX6QDL_PAD_EIM_D21__GPIO3_IO21  0x80000000
+				MX6QDL_PAD_EIM_D16__GPIO3_IO16  0x80000000
+				MX6QDL_PAD_EIM_BCLK__GPIO6_IO31 0x80000000
 				MX6QDL_PAD_ENET_CRS_DV__GPIO1_IO25 0x80000000
-				MX6QDL_PAD_EIM_D26__GPIO3_IO26 0x80000000
+				/* leavs patched for uart2 MX6QDL_PAD_EIM_D26__GPIO3_IO26 0x80000000 */
 				MX6QDL_PAD_EIM_CS1__GPIO2_IO24 0x80000000
 				MX6QDL_PAD_ENET_RXD0__GPIO1_IO27 0x80000000
-				MX6QDL_PAD_EIM_A25__GPIO5_IO02 0x80000000
-				MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000
 				MX6QDL_PAD_EIM_EB3__GPIO2_IO31 0x80000000
-				MX6QDL_PAD_SD1_CMD__GPIO1_IO18 0x80000000
-				MX6QDL_PAD_EIM_D16__GPIO3_IO16 0x80000000
-				MX6QDL_PAD_SD3_RST__GPIO7_IO08	0x80000000
+				/* leavs patched for enable pwm4 MX6QDL_PAD_SD1_CMD__GPIO1_IO18 0x80000000 */
+				MX6QDL_PAD_SD3_RST__GPIO7_IO08	0x1b0b0
 				MX6QDL_PAD_GPIO_9__GPIO1_IO09 	0x80000000
 				MX6QDL_PAD_EIM_DA9__GPIO3_IO09 0x80000000
 				MX6QDL_PAD_GPIO_1__WDOG2_B 0x80000000
+				/* MX6QDL_PAD_GPIO_2__GPIO1_IO02 0x1b0b0 */
 				MX6QDL_PAD_NANDF_CS0__GPIO6_IO11 0x80000000
 				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14 0x80000000
 				MX6QDL_PAD_NANDF_CS2__GPIO6_IO15 0x80000000
 				MX6QDL_PAD_NANDF_CS3__GPIO6_IO16 0x80000000
+				MX6QDL_PAD_SD3_DAT4__GPIO7_IO01 0x80000000
+                                MX6QDL_PAD_SD3_DAT5__GPIO7_IO00 0x80000000
+                                MX6QDL_PAD_SD1_DAT0__GPIO1_IO16 0x80000000      /* leavs patched for enable lvds power */
+                                MX6QDL_PAD_GPIO_19__GPIO4_IO05 0X80000000       /* leavs add for ADXL345 */
+                                MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28 0X80000000    /*leavs add for LCD cap touch screen and GPIO1_28*/
+                                MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000     /* GPIO1_29 */
+                                MX6QDL_PAD_ENET_TXD0__GPIO1_IO30 0X80000000     /* GPIO1_30 */
+                                MX6QDL_PAD_EIM_D23__GPIO3_IO23 0x80000000       /* GPIO3_23 */
+                                MX6QDL_PAD_EIM_D30__GPIO3_IO30  0x80000000      /* GPIO3_30 */
+                                MX6QDL_PAD_EIM_D31__GPIO3_IO31  0X80000000      /* GPIO3_31 */
+                                MX6QDL_PAD_KEY_COL2__GPIO4_IO10 0X80000000      /* GPIO4_10 */
+                                MX6QDL_PAD_EIM_A25__GPIO5_IO02  0X80000000      /* GPIO5_2 */
 			>;
 		};
 
@@ -586,9 +570,9 @@
 
 		pinctrl_ecspi1: ecspi1grp {
 			fsl,pins = <
-				MX6QDL_PAD_KEY_COL1__ECSPI1_MISO	0x100b1
-				MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI	0x100b1
-				MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK	0x100b1
+				/*MX6QDL_PAD_KEY_COL1__ECSPI1_MISO	0x100b1*/
+				/*MX6QDL_PAD_KEY_ROW0__ECSPI1_MOSI	0x100b1*/
+				/*MX6QDL_PAD_KEY_COL0__ECSPI1_SCLK	0x100b1*/
 			>;
 		};
 
@@ -619,6 +603,20 @@
 			>;
 		};
 
+		pinctrl_flexcan1: flexcan1grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_GPIO_7__FLEXCAN1_TX        0x80000000
+                                MX6QDL_PAD_GPIO_8__FLEXCAN1_RX        0x80000000
+                        >;
+                };
+
+                pinctrl_flexcan2: flexcan2grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX        0x80000000
+                                MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX        0x80000000
+                        >;
+                };
+
 		pinctrl_gpio_keys: gpio_keysgrp {
 			fsl,pins = <
 				MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
@@ -718,6 +716,12 @@
 			>;
 		};
 
+		pinctrl_pwm4: pwm4grp {
+                        fsl,pins = <
+                                MX6QDL_PAD_SD1_CMD__PWM4_OUT            0x1b0b1
+                        >;
+                };
+
 		pinctrl_uart1: uart1grp {
 			fsl,pins = <
 				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA	0x1b0b1
@@ -725,6 +729,36 @@
 			>;
 		};
 
+		pinctrl_uart1_2: uart1grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_DAT7__UART1_TX_DATA	0x1b0b1
+				MX6QDL_PAD_SD3_DAT6__UART1_RX_DATA	0x1b0b1
+			>;
+		};
+
+		pinctrl_uart2_1: uart2grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D26__UART2_TX_DATA       0x1b0b1
+                                MX6QDL_PAD_EIM_D27__UART2_RX_DATA       0x1b0b1
+                                MX6QDL_PAD_EIM_D28__UART2_CTS_B         0x1b0b1
+                                MX6QDL_PAD_EIM_D29__UART2_RTS_B         0x1b0b1
+                        >;
+                };
+
+		pinctrl_uart3_1: uart3grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_EIM_D24__UART3_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_EIM_D25__UART3_RX_DATA      0x1b0b1
+                        >;
+                };
+
+                pinctrl_uart4_1: uart4grp-1 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL0__UART4_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_KEY_ROW0__UART4_RX_DATA      0x1b0b1
+                        >;
+                };
+
 		pinctrl_uart5_1: uart5grp-1 {
 			fsl,pins = <
 				MX6QDL_PAD_KEY_COL1__UART5_TX_DATA	0x1b0b1
@@ -734,6 +768,13 @@
 			>;
 		};
 
+		pinctrl_uart5_2: uart5grp-2 {
+                        fsl,pins = <
+                                MX6QDL_PAD_KEY_COL1__UART5_TX_DATA      0x1b0b1
+                                MX6QDL_PAD_KEY_ROW1__UART5_RX_DATA      0x1b0b1
+                        >;
+                };
+
 		pinctrl_uart5dte_1: uart5dtegrp-1 {
 			fsl,pins = <
 				MX6QDL_PAD_KEY_ROW1__UART5_TX_DATA	0x1b0b1
@@ -764,6 +805,17 @@
 			>;
 		};
 
+		pinctrl_usdhc2_2: usdhc2grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_CMD__SD2_CMD		0x17079
+				MX6QDL_PAD_SD2_CLK__SD2_CLK		0x10079
+				MX6QDL_PAD_SD2_DAT0__SD2_DATA0		0x17079
+				MX6QDL_PAD_SD2_DAT1__SD2_DATA1		0x17079
+				MX6QDL_PAD_SD2_DAT2__SD2_DATA2		0x17079
+				MX6QDL_PAD_SD2_DAT3__SD2_DATA3		0x17079
+			>;
+		};
+
 		pinctrl_usdhc3: usdhc3grp {
 			fsl,pins = <
 				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
@@ -779,6 +831,17 @@
 			>;
 		};
 
+		pinctrl_usdhc3_2: usdhc3grp-2 {
+			fsl,pins = <
+				MX6QDL_PAD_SD3_CMD__SD3_CMD		0x17059
+				MX6QDL_PAD_SD3_CLK__SD3_CLK		0x10059
+				MX6QDL_PAD_SD3_DAT0__SD3_DATA0		0x17059
+				MX6QDL_PAD_SD3_DAT1__SD3_DATA1		0x17059
+				MX6QDL_PAD_SD3_DAT2__SD3_DATA2		0x17059
+				MX6QDL_PAD_SD3_DAT3__SD3_DATA3		0x17059
+			>;
+		};
+
 		pinctrl_usdhc4: usdhc4grp {
 			fsl,pins = <
 				MX6QDL_PAD_SD4_CMD__SD4_CMD		0x17059
@@ -809,10 +872,33 @@
 	status = "okay";
 };
 
+&flexcan1 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_flexcan1>;
+        /* pinctrl-assert-gpios = <&max7310_b 3 GPIO_ACTIVE_HIGH>; TX */
+        /* trx-en-gpio = <&max7310_b 6 GPIO_ACTIVE_HIGH>;*/
+        /* trx-stby-gpio = <&max7310_b 5 GPIO_ACTIVE_HIGH>;*/
+        status = "okay";
+};
+
+&flexcan2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_flexcan2>;
+        /*trx-en-gpio = <&max7310_c 6 GPIO_ACTIVE_HIGH>;*/
+        /*trx-stby-gpio = <&max7310_c 5 GPIO_ACTIVE_HIGH>;*/
+        status = "okay";
+};
+
+&gpio1 {
+	pinctrl-names = "default";
+	power-en-gpio = <&gpio1 16 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
 &gpc {
 	/* use ldo-bypass, u-boot will check it and configure */
-	fsl,ldo-bypass = <1>;
-	fsl,wdog-reset = <2>;
+	fsl,ldo-bypass = <0>;
+	fsl,wdog-reset = <1>;
 };
 
 &hdmi_audio {
@@ -839,46 +925,146 @@
 
 &ldb {
 	status = "okay";
+	/*split-mode;*/
 
 	lvds-channel@0 {
 		fsl,data-mapping = "spwg";
-		fsl,data-width = <18>;
+		fsl,data-width = <24>;
+		primary;
 		status = "okay";
-
+		
 		display-timings {
-			native-mode = <&timing0>;
-			timing0: hsd100pxn1 {
-				clock-frequency = <65000000>;
-				hactive = <1024>;
-				vactive = <768>;
-				hback-porch = <220>;
+			native-mode = <&timing010>;
+			timing07: IONOLUX-WSVGA {
+                                clock-frequency = <51200000>;
+                                hactive = <1024>;
+                                vactive = <600>;
+                                hback-porch = <40>;
+                                hfront-porch = <220>;
+                                vback-porch = <5>;
+                                vfront-porch = <20>;
+                                hsync-len = <60>;
+                                vsync-len = <10>;
+                        };
+			timing010: CHIMEI-WXGA {
+				clock-frequency = <71100000>;
+				hactive = <1280>;
+				vactive = <800>;
+				hback-porch = <40>;
 				hfront-porch = <40>;
-				vback-porch = <21>;
-				vfront-porch = <7>;
-				hsync-len = <60>;
+				vback-porch = <3>;
+				vfront-porch = <10>;
+				hsync-len = <80>;
 				vsync-len = <10>;
 			};
+			timing028: BOE28 {
+                                clock-frequency = <148500000>;
+                                hactive = <1920>;
+                                vactive = <360>;
+                                hback-porch = <139>;
+                                hfront-porch = <139>;
+                                vback-porch = <14>;
+                                vfront-porch = <14>;
+                                hsync-len = <2>;
+                                vsync-len = <2>;
+                        };
+                        timing019: CHIMEI-WXGA+ {
+                                clock-frequency = <88800000>;
+                                hactive = <1440>;
+                                vactive = <900>;
+                                hback-porch = <60>;
+                                hfront-porch = <60>;
+                                vback-porch = <20>;
+                                vfront-porch = <20>;
+                                hsync-len = <40>;
+                                vsync-len = <12>;
+                        };
+                        timing0215: CHIMEI-AUO215 {
+                                clock-frequency = <148640000>;
+                                hactive = <1920>;
+                                vactive = <1080>;
+                                hback-porch = <100>;
+                                hfront-porch = <100>;
+                                vback-porch = <40>;
+                                vfront-porch = <40>;
+                                hsync-len = <80>;
+                                vsync-len = <10>;
+                        };
+                        timing012: IVO-VGA121 {                 /* 12 and 15 use the same timing  */
+                                clock-frequency = <65000000>;
+                                hactive = <1024>;
+                                vactive = <768>;
+                                hback-porch = <48>;
+                                hfront-porch = <240>;
+                                vback-porch = <23>;
+                                vfront-porch = <3>;
+                                hsync-len = <32>;
+                                vsync-len = <12>;
+                        };
+			timing0170: AUO170 {
+				clock-frequency = <108000000>;
+				hactive = <1280>;
+				vactive = <1024>;
+				hback-porch = <150>;
+				hfront-porch = <150>;
+				vback-porch = <40>;
+				vfront-porch = <40>;
+				hsync-len = <108>;
+				vsync-len = <4>;
+			};
 		};
 	};
 
 	lvds-channel@1 {
 		fsl,data-mapping = "spwg";
-		fsl,data-width = <18>;
-		primary;
+		fsl,data-width = <24>;
 		status = "okay";
 
 		display-timings {
-			native-mode = <&timing1>;
-			timing1: hsd100pxn1 {
-				clock-frequency = <65000000>;
-				hactive = <1024>;
-				vactive = <768>;
-				hback-porch = <220>;
-				hfront-porch = <40>;
-				vback-porch = <21>;
-				vfront-porch = <7>;
-				hsync-len = <60>;
-				vsync-len = <10>;
+			native-mode = <&timing128>;
+			timing128: BOE28 {
+                                clock-frequency = <148500000>;
+                                hactive = <1920>;
+                                vactive = <360>;
+                                hback-porch = <139>;
+                                hfront-porch = <139>;
+                                vback-porch = <14>;
+                                vfront-porch = <14>;
+                                hsync-len = <2>;
+                                vsync-len = <2>;
+                        };
+                        timing119: CHIMEI-WXGA+ {
+                                clock-frequency = <88800000>;
+                                hactive = <1440>;
+                                vactive = <900>;
+                                hback-porch = <60>;
+                                hfront-porch = <60>;
+                                vback-porch = <20>;
+                                vfront-porch = <20>;
+                                hsync-len = <40>;
+                                vsync-len = <12>;
+                        };
+                        timing1215: CHIMEI-AUO215 {
+                                clock-frequency = <148640000>;
+                                hactive = <1920>;
+                                vactive = <1080>;
+                                hback-porch = <100>;
+                                hfront-porch = <100>;
+                                vback-porch = <40>;
+                                vfront-porch = <40>;
+                                hsync-len = <80>;
+                                vsync-len = <10>;
+                        };
+			timing1170: AUO170 {
+				clock-frequency = <108000000>;
+				hactive = <1280>;
+				vactive = <1024>;
+				hback-porch = <150>;
+				hfront-porch = <150>;
+				vback-porch = <40>;
+				vfront-porch = <40>;
+				hsync-len = <108>;
+				vsync-len = <4>;
 			};
 		};
 	};
@@ -913,6 +1099,17 @@
 	status = "okay";
 };
 
+&pwm4 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_pwm4>;
+        status = "disable";
+};
+
+&ssi1 {
+        fsl,mode = "i2s-slave";
+        status = "okay";
+};
+
 &ssi2 {
 	fsl,mode = "i2s-slave";
 	status = "okay";
@@ -920,17 +1117,40 @@
 
 &uart1 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_uart1>;
+	pinctrl-0 = <&pinctrl_uart1_2>;
 	status = "okay";
 };
 
+&uart2 {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_uart2_1>;
+        fsl,uart-has-rtscts;
+        status = "okay";
+};
+
+&uart3 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart3_1>;
+    status = "okay";
+};
+
+&uart4 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart4_1>;
+    status = "okay";
+};
+
+&uart5 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart5_2>;
+    status = "okay";
+};
+
 &usbh1 {
-	vbus-supply = <&reg_usb_h1_vbus>;
 	status = "okay";
 };
 
 &usbotg {
-	vbus-supply = <&reg_usb_otg_vbus>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_usbotg>;
 	disable-over-current;
@@ -941,27 +1161,31 @@
 };
 
 &usdhc2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc2>;
-	bus-width = <8>;
-	cd-gpios = <&gpio2 2 0>;
-	wp-gpios = <&gpio2 3 0>;
-	no-1-8-v;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usdhc2_2>;
+        bus-width = <8>;        /* LEAVS PATCHED 2 bus-width = <4>; */
+        cd-gpios = <&gpio1 4 0>;
+        /* LEAVS PATCHED 1 wifi-host; */
+        no-1-8-v;
+        /* LEAVS PATCHED 2 pm-ignore-notify; */
+        keep-power-in-suspend;
+        enable-sdio-wakeup;
+        status = "okay";
 };
 
 &usdhc3 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_usdhc3>;
-	bus-width = <8>;
-	cd-gpios = <&gpio2 0 0>;
-	wp-gpios = <&gpio2 1 0>;
-	no-1-8-v;
-	keep-power-in-suspend;
-	enable-sdio-wakeup;
-	status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_usdhc3_2>;
+        bus-width = <4>;                        /* LEAVS PATCHED 2 bus-width = <8>; */
+        /* LEAVS PATCHED 1 cd-gpios = <&gpio2 0 0>;     */
+        /* LEAVS PATCHED 1 wp-gpios = <&gpio2 1 0>; */
+        wifi-host;                                      /* LEAVS PATCHED 1 */
+        no-1-8-v;
+        pm-ignore-notify;                       /* LEAVS PATCHED 2 */
+        keep-power-in-suspend;
+        enable-sdio-wakeup;
+        /*vmmc-supply = <&wlreg_on>;*/
+        status = "okay";
 };
 
 &usdhc4 {
diff --git a/arch/arm/configs/imx6_7ft_defconfig b/arch/arm/configs/imx6_7ft_defconfig
new file mode 100755
index 0000000..777d805
--- /dev/null
+++ b/arch/arm/configs/imx6_7ft_defconfig
@@ -0,0 +1,437 @@
+CONFIG_LOCALVERSION="-1.1.1_ga"
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_GPIO_PCA953X=y
+CONFIG_ARCH_MXC=y
+CONFIG_MACH_IMX51_DT=y
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_MX6_CLK_FOR_BOOTUI_TRANS=y
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0 is not set
+CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0=y
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0 is not set
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_VF610=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_VMSPLIT_2G=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_CMA=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7D_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=m
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_NETFILTER=y
+CONFIG_VLAN_8021Q=y
+CONFIG_LLC2=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_M_CAN=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_BT_ATH3K=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_MICREL_PHY=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_CDC_EEM=m
+# CONFIG_RTL_CARDS is not set
+CONFIG_RTL8723BS=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_IMX=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_FT5X06=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_ISL29023=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_FSL_OTP=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_74X164=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_MAG3110=y
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_MAX17135=y
+CONFIG_MFD_SI476X_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=m
+CONFIG_MXC_CAMERA_OV5640=m
+CONFIG_MXC_CAMERA_OV5642=m
+CONFIG_MXC_CAMERA_OV5640_MIPI=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+CONFIG_MXC_VADC=m
+CONFIG_MXC_MIPI_CSI=m
+CONFIG_MXC_CAMERA_OV5647_MIPI=m
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_MX3=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=y
+CONFIG_RADIO_SI476X=y
+CONFIG_SOC_CAMERA_OV2640=y
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+CONFIG_FB=y
+CONFIG_FB_MXS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_MIPI_DSI_SAMSUNG=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_EINK_V2_PANEL=y
+CONFIG_FB_MXS_SII902X=y
+CONFIG_FB_MXC_DCIC=m
+CONFIG_HANNSTAR_CABC=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_SII902X=y
+CONFIG_SND_SOC_IMX_WM8958=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_USB=y
+CONFIG_USB_OTG_WHITELIST=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_HCD_TEST_MODE=y
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MXC_IPU=y
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_IPU_V3_PRE=y
+CONFIG_MXC_MIPI_CSI2=y
+CONFIG_MXC_SIM=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_VF610_ADC=y
+CONFIG_AD2802A=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_UTF8=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SINK_TPIU=y
+CONFIG_CORESIGHT_SINK_ETBV10=y
+CONFIG_CORESIGHT_SOURCE_ETM3X=y
+CONFIG_SECURITYFS=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_LRW=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
diff --git a/arch/arm/configs/imx6_7ft_has_console_logo_defconfig b/arch/arm/configs/imx6_7ft_has_console_logo_defconfig
new file mode 100755
index 0000000..d88b97a
--- /dev/null
+++ b/arch/arm/configs/imx6_7ft_has_console_logo_defconfig
@@ -0,0 +1,443 @@
+CONFIG_LOCALVERSION="-1.1.1_ga"
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_GPIO_PCA953X=y
+CONFIG_ARCH_MXC=y
+CONFIG_MACH_IMX51_DT=y
+CONFIG_MACH_EUKREA_CPUIMX51SD=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0 is not set
+# CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0 is not set
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_VF610=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_VMSPLIT_2G=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_CMA=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7D_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=m
+CONFIG_PM_RUNTIME=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_NETFILTER=y
+CONFIG_VLAN_8021Q=y
+CONFIG_LLC2=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_M_CAN=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_BT_ATH3K=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_MICREL_PHY=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_CDC_EEM=m
+# CONFIG_RTL_CARDS is not set
+CONFIG_RTL8723BS=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_IMX=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_FT5X06=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_ISL29023=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_FSL_OTP=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_74X164=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_MAG3110=y
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_MAX17135=y
+CONFIG_MFD_SI476X_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=m
+CONFIG_MXC_CAMERA_OV5640=m
+CONFIG_MXC_CAMERA_OV5642=m
+CONFIG_MXC_CAMERA_OV5640_MIPI=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+CONFIG_MXC_VADC=m
+CONFIG_MXC_MIPI_CSI=m
+CONFIG_MXC_CAMERA_OV5647_MIPI=m
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_MX3=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=y
+CONFIG_RADIO_SI476X=y
+CONFIG_SOC_CAMERA_OV2640=y
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+CONFIG_FB=y
+CONFIG_FB_MXS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_MIPI_DSI_SAMSUNG=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_EINK_V2_PANEL=y
+CONFIG_FB_MXS_SII902X=y
+CONFIG_FB_MXC_DCIC=m
+CONFIG_HANNSTAR_CABC=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_SII902X=y
+CONFIG_SND_SOC_IMX_WM8958=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_USB=y
+CONFIG_USB_OTG_WHITELIST=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_HCD_TEST_MODE=y
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MXC_IPU=y
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_IPU_V3_PRE=y
+CONFIG_MXC_MIPI_CSI2=y
+CONFIG_MXC_SIM=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_DS1307=y
+CONFIG_DMADEVICES=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_VF610_ADC=y
+CONFIG_AD2802A=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_UTF8=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_CORESIGHT=y
+CONFIG_CORESIGHT_LINK_AND_SINK_TMC=y
+CONFIG_CORESIGHT_SINK_TPIU=y
+CONFIG_CORESIGHT_SINK_ETBV10=y
+CONFIG_CORESIGHT_SOURCE_ETM3X=y
+CONFIG_SECURITYFS=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_LRW=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 04ec006..43b460d 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -837,6 +837,57 @@ config SOC_IMX6Q
 	help
 	  This enables support for Freescale i.MX6 Quad processor.
 
+config MX6_CLK_FOR_BOOTUI_TRANS
+	bool "MX6 clk setting for smooth UI transtion from bootloader to kernel"
+	depends on SOC_IMX6Q
+	default n
+	help
+	 This is choosed to keep enable IPU related clocks and PWM clocks and
+	 avoid setting IPU related clocks' parents when initializing clock tree
+	 so that bootloader splashimage can transition to kernel smoothly.
+
+choice
+	depends on MX6_CLK_FOR_BOOTUI_TRANS
+	prompt "Select Display Interface"
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0
+	bool "Smooth UI transtion on LCD, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on LCD panel which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0
+	bool "Smooth UI transtion on LVDS, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	bool "Smooth UI transtion on LVDS, IPU1, DI1."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU1 DI1 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	bool "Smooth UI transtion on LVDS, IPU2, DI1."
+	help
+	 This is choosed to keep enable IPU related setting on LVDS panel which
+	 is connected on IPU2 DI1 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0
+	bool "Smooth UI transtion on HDMI, IPU1, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on HDMI display which
+	 is connected on IPU1 DI0 port.
+
+config MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0
+	bool "Smooth UI transtion on HDMI, IPU2, DI0."
+	help
+	 This is choosed to keep enable IPU related setting on HDMI display which
+	 is connected on IPU2 DI0 port.
+
+endchoice
+
 config SOC_IMX6SL
 	bool "i.MX6 SoloLite support"
 	select HAVE_IMX_RNG
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index 83eb3ba..0c98c8d 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -303,6 +303,11 @@ static void init_ldb_clks(struct device_node *np)
 	ldb_di1_sel[1] = ldb_di1_sel[0] | 4;
 	ldb_di1_sel[2] = ldb_di1_sel[3] | 4;
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	return;
+#else
 	mmdc_ch1_handshake(false);
 	mmdc_ch1_disable();
 
@@ -315,10 +320,14 @@ static void init_ldb_clks(struct device_node *np)
 
 	mmdc_ch1_reenable();
 	mmdc_ch1_handshake(true);
+#endif
 }
 
 static void disable_anatop_clocks(void)
 {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	return;
+#else
 	u32 reg;
 
 	/* Make sure PFDs are disabled at boot. */
@@ -340,6 +349,7 @@ static void disable_anatop_clocks(void)
 	reg = readl_relaxed(anatop_base + 0xa0);
 	reg &= ~(1 << 13);
 	writel_relaxed(reg, anatop_base + 0xa0);
+#endif
 }
 
 static void __init imx6q_clocks_init(struct device_node *ccm_node)
@@ -795,10 +805,42 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_PRE_SEL], clk[IMX6QDL_CLK_PLL5_VIDEO_DIV]);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_LDB_DI0]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_LDB_DI1]);
+#endif
+#else
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI0_SEL], clk[IMX6QDL_CLK_IPU1_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#endif
 	if (cpu_is_imx6dl()) {
 		imx_clk_set_rate(clk[IMX6QDL_CLK_PLL3_PFD1_540M], 540000000);
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
@@ -810,10 +852,11 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	} else if (cpu_is_imx6q()) {
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_MMDC_CH0_AXI]);
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_SEL], clk[IMX6QDL_CLK_MMDC_CH0_AXI]);
-		/* set eim_slow to 132Mhz */
-		imx_clk_set_rate(clk[IMX6QDL_CLK_EIM_SLOW], 132000000);
 	}
 
+	imx_clk_set_parent(clk[IMX6QDL_CLK_AXI_ALT_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_AXI_SEL], clk[IMX6QDL_CLK_AXI_ALT_SEL]);
+
 	/*
 	 * The gpmi needs 100MHz frequency in the EDO/Sync mode,
 	 * We can not get the 100MHz from the pll2_pfd0_352m.
@@ -870,6 +913,9 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	if (IS_ENABLED(CONFIG_PCI_IMX6))
 		imx_clk_set_parent(clk[IMX6QDL_CLK_LVDS1_SEL], clk[IMX6QDL_CLK_SATA_REF]);
 
+	/* set eim_slow to 135Mhz */
+	imx_clk_set_rate(clk[IMX6QDL_CLK_EIM_SLOW], 135000000);
+
 	/*
 	 * Enable clocks only after both parent and rate are all initialized
 	 * as needed
diff --git a/arch/arm/mach-imx/mach-imx6q.c b/arch/arm/mach-imx/mach-imx6q.c
index 039d9c2..1a16152 100644
--- a/arch/arm/mach-imx/mach-imx6q.c
+++ b/arch/arm/mach-imx/mach-imx6q.c
@@ -40,6 +40,9 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/system_misc.h>
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#include <linux/memblock.h>
+#endif
 
 #include "common.h"
 #include "cpuidle.h"
@@ -342,12 +345,13 @@ static void __init imx6q_csi_mux_init(void)
 
 	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
 	if (!IS_ERR(gpr)) {
-		if (of_machine_is_compatible("fsl,imx6q-sabresd") ||
-			of_machine_is_compatible("fsl,imx6q-sabreauto"))
-			regmap_update_bits(gpr, IOMUXC_GPR1, 1 << 19, 1 << 19);
-		else if (of_machine_is_compatible("fsl,imx6dl-sabresd") ||
+		if (of_machine_is_compatible("fsl,imx6q-sabresd")) {
+			regmap_update_bits(gpr, IOMUXC_GPR1, 3 << 19, 0 << 19);
+		} else if (of_machine_is_compatible("fsl,imx6q-sabreauto")) {
+			regmap_update_bits(gpr, IOMUXC_GPR1, 3 << 19, 1 << 19);
+		} else if (of_machine_is_compatible("fsl,imx6dl-sabresd") ||
 			 of_machine_is_compatible("fsl,imx6dl-sabreauto"))
-			regmap_update_bits(gpr, IOMUXC_GPR13, 0x3F, 0x0C);
+			regmap_update_bits(gpr, IOMUXC_GPR13, 0x3F, 0x1C);
 	} else {
 		pr_err("%s(): failed to find fsl,imx6q-iomux-gpr regmap\n",
 		       __func__);
@@ -543,6 +547,29 @@ static const char *imx6q_dt_compat[] __initdata = {
 	NULL,
 };
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+static void imx6q_init_reserve(void)
+{
+	phys_addr_t base, size;
+
+	/*
+	 * Frame buffer base address.
+	 * It is same as CONFIG_FB_BASE in Uboot.
+	 */
+	base = 0x18800000;
+
+	/*
+	 * Reserved display memory size.
+	 * It should be bigger than 3 x framer buffer size.
+	 * For 1080P 32 bpp, 1920*1080*4*3 = 0x017BB000.
+	 */
+	size = 0x01800000;
+
+	memblock_reserve(base, size);
+	memblock_remove(base, size);
+}
+#endif
+
 DT_MACHINE_START(IMX6Q, "Freescale i.MX6 Quad/DualLite (Device Tree)")
 	/*
 	 * i.MX6Q/DL maps system memory at 0x10000000 (offset 256MiB), and
@@ -556,5 +583,8 @@ DT_MACHINE_START(IMX6Q, "Freescale i.MX6 Quad/DualLite (Device Tree)")
 	.init_machine	= imx6q_init_machine,
 	.init_late      = imx6q_init_late,
 	.dt_compat	= imx6q_dt_compat,
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	.reserve        = imx6q_init_reserve,
+#endif
 	.restart	= mxc_restart,
 MACHINE_END
diff --git a/drivers/mfd/mxc-hdmi-core.c b/drivers/mfd/mxc-hdmi-core.c
index 76e79b7..bab0599 100644
--- a/drivers/mfd/mxc-hdmi-core.c
+++ b/drivers/mfd/mxc-hdmi-core.c
@@ -55,7 +55,12 @@ static struct clk *mipi_core_clk;
 static spinlock_t irq_spinlock;
 static spinlock_t edid_spinlock;
 static unsigned int sample_rate;
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+static unsigned long pixel_clk_rate = 148500000;
+#else
 static unsigned long pixel_clk_rate;
+#endif
 static struct clk *pixel_clk;
 static int hdmi_ratio;
 int mxc_hdmi_ipu_id;
@@ -653,7 +658,12 @@ static int mxc_hdmi_core_probe(struct platform_device *pdev)
 
 	pixel_clk = NULL;
 	sample_rate = 48000;
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	/* Skip pixel_clk_rate set */
+#else
 	pixel_clk_rate = 0;
+#endif
 	hdmi_ratio = 100;
 
 	spin_lock_init(&irq_spinlock);
@@ -797,6 +807,20 @@ static struct platform_driver mxc_hdmi_core_driver = {
 	.remove = __exit_p(mxc_hdmi_core_remove),
 };
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+static int __init mxc_hdmi_audio_clock_setup(char *options)
+{
+	if (!strcmp(options, "74250000"))
+		pixel_clk_rate = 74250000;
+	else if (!strcmp(options, "148500000"))
+		pixel_clk_rate = 148500000;
+
+	return 1;
+}
+__setup("hdmi_audio_clk=", mxc_hdmi_audio_clock_setup);
+#endif
+
 static int __init mxc_hdmi_core_init(void)
 {
 	return platform_driver_probe(&mxc_hdmi_core_driver,
diff --git a/drivers/mxc/ipu3/ipu_common.c b/drivers/mxc/ipu3/ipu_common.c
index 7a27756..f0fc33f 100644
--- a/drivers/mxc/ipu3/ipu_common.c
+++ b/drivers/mxc/ipu3/ipu_common.c
@@ -130,111 +130,108 @@ static inline bool idma_is_set(struct ipu_soc *ipu, uint32_t reg, uint32_t dma)
 
 static int ipu_clk_setup_enable(struct ipu_soc *ipu)
 {
-	char pixel_clk_0[] = "ipu1_pclk_0";
-	char pixel_clk_1[] = "ipu1_pclk_1";
-	char pixel_clk_0_sel[] = "ipu1_pclk0_sel";
-	char pixel_clk_1_sel[] = "ipu1_pclk1_sel";
-	char pixel_clk_0_div[] = "ipu1_pclk0_div";
-	char pixel_clk_1_div[] = "ipu1_pclk1_div";
-	char *ipu_pixel_clk_sel[] = { "ipu1", "ipu1_di0", "ipu1_di1", };
-	char *pclk_sel;
+	char pixel_clk[11];
+	char pixel_clk_sel[15];
+	char pixel_clk_div[15];
+	char pixel_clk_parent0[5];
+	char pixel_clk_parent1[9];
+	char *pixel_clk_parents[2];
+	char di_clk[4];
+	char di_clk_sel[8];
 	struct clk *clk;
+	unsigned int di;
+	unsigned int ipu_id;	/* for clk naming */
 	int ret;
-	int i;
 
-	pixel_clk_0[3] += ipu->id;
-	pixel_clk_1[3] += ipu->id;
-	pixel_clk_0_sel[3] += ipu->id;
-	pixel_clk_1_sel[3] += ipu->id;
-	pixel_clk_0_div[3] += ipu->id;
-	pixel_clk_1_div[3] += ipu->id;
-	for (i = 0; i < ARRAY_SIZE(ipu_pixel_clk_sel); i++) {
-		pclk_sel = ipu_pixel_clk_sel[i];
-		pclk_sel[3] += ipu->id;
-	}
 	dev_dbg(ipu->dev, "ipu_clk = %lu\n", clk_get_rate(ipu->ipu_clk));
 
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_0_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di0 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[0] = clk;
-	clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_1_sel,
-			(const char **)ipu_pixel_clk_sel,
-			ARRAY_SIZE(ipu_pixel_clk_sel),
-			0, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk_register mux di1 failed");
-		return PTR_ERR(clk);
-	}
-	ipu->pixel_clk_sel[1] = clk;
-
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_0_div,
-				pixel_clk_0_sel, 0, ipu->id, 0, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di0 div failed");
-		return PTR_ERR(clk);
-	}
-	clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_1_div,
-			pixel_clk_1_sel, CLK_SET_RATE_PARENT, ipu->id, 1, 0);
-	if (IS_ERR(clk)) {
-		dev_err(ipu->dev, "clk register di1 div failed");
-		return PTR_ERR(clk);
-	}
-
-	ipu->pixel_clk[0] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_0,
-				pixel_clk_0_div, CLK_SET_RATE_PARENT,
-				ipu->id, 0, 0);
-	if (IS_ERR(ipu->pixel_clk[0])) {
-		dev_err(ipu->dev, "clk register di0 gate failed");
-		return PTR_ERR(ipu->pixel_clk[0]);
-	}
-	ipu->pixel_clk[1] = clk_register_gate_pix_clk(ipu->dev, pixel_clk_1,
-				pixel_clk_1_div, CLK_SET_RATE_PARENT,
-				ipu->id, 1, 0);
-	if (IS_ERR(ipu->pixel_clk[1])) {
-		dev_err(ipu->dev, "clk register di1 gate failed");
-		return PTR_ERR(ipu->pixel_clk[1]);
-	}
-
-	ret = clk_set_parent(ipu->pixel_clk_sel[0], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
-	}
+	ipu_id = ipu->id + 1;
+
+	pixel_clk_parents[0] = pixel_clk_parent0;
+	pixel_clk_parents[1] = pixel_clk_parent1;
+
+	for (di = 0; di < 2; di++) {
+		snprintf(pixel_clk_sel, sizeof(pixel_clk_sel),
+				"ipu%u_pclk%u_sel", ipu_id, di);
+		snprintf(pixel_clk_parent0, sizeof(pixel_clk_parent0),
+				"ipu%u", ipu_id);
+		snprintf(pixel_clk_parent1, sizeof(pixel_clk_parent1),
+				"ipu%u_di%u", ipu_id, di);
+		clk = clk_register_mux_pix_clk(ipu->dev, pixel_clk_sel,
+				(const char **)pixel_clk_parents,
+				ARRAY_SIZE(pixel_clk_parents),
+				0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u mux clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
+		ipu->pixel_clk_sel[di] = clk;
+
+		snprintf(pixel_clk_div, sizeof(pixel_clk_div),
+				"ipu%u_pclk%u_div", ipu_id, di);
+		clk = clk_register_div_pix_clk(ipu->dev, pixel_clk_div,
+					pixel_clk_sel, 0, ipu->id, di, 0);
+		if (IS_ERR(clk)) {
+			dev_err(ipu->dev, "di%u div clk register failed\n", di);
+			return PTR_ERR(clk);
+		}
 
-	ret = clk_set_parent(ipu->pixel_clk_sel[1], ipu->ipu_clk);
-	if (ret) {
-		dev_err(ipu->dev, "clk set parent failed");
-		return ret;
-	}
+		snprintf(pixel_clk, sizeof(pixel_clk),
+				"ipu%u_pclk%u", ipu_id, di);
+		ipu->pixel_clk[di] = clk_register_gate_pix_clk(ipu->dev,
+					pixel_clk, pixel_clk_div,
+					CLK_SET_RATE_PARENT, ipu->id, di, 0);
+		if (IS_ERR(ipu->pixel_clk[di])) {
+			dev_err(ipu->dev,
+					"di%u gate clk register failed\n", di);
+			return PTR_ERR(ipu->pixel_clk[di]);
+		}
 
-	ipu->di_clk[0] = devm_clk_get(ipu->dev, "di0");
-	if (IS_ERR(ipu->di_clk[0])) {
-		dev_err(ipu->dev, "clk_get di0 failed");
-		return PTR_ERR(ipu->di_clk[0]);
-	}
-	ipu->di_clk[1] = devm_clk_get(ipu->dev, "di1");
-	if (IS_ERR(ipu->di_clk[1])) {
-		dev_err(ipu->dev, "clk_get di1 failed");
-		return PTR_ERR(ipu->di_clk[1]);
-	}
+		ret = clk_set_parent(ipu->pixel_clk_sel[di], ipu->ipu_clk);
+		if (ret) {
+			dev_err(ipu->dev, "pixel clk set parent failed\n");
+			return ret;
+		}
 
-	ipu->di_clk_sel[0] = devm_clk_get(ipu->dev, "di0_sel");
-	if (IS_ERR(ipu->di_clk_sel[0])) {
-		dev_err(ipu->dev, "clk_get di0_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[0]);
-	}
-	ipu->di_clk_sel[1] = devm_clk_get(ipu->dev, "di1_sel");
-	if (IS_ERR(ipu->di_clk_sel[1])) {
-		dev_err(ipu->dev, "clk_get di1_sel failed");
-		return PTR_ERR(ipu->di_clk_sel[1]);
+		snprintf(di_clk, sizeof(di_clk), "di%u", di);
+		ipu->di_clk[di] = devm_clk_get(ipu->dev, di_clk);
+		if (IS_ERR(ipu->di_clk[di])) {
+			dev_err(ipu->dev, "di%u clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk[di]);
+		}
+
+		snprintf(di_clk_sel, sizeof(di_clk_sel), "di%u_sel", di);
+		ipu->di_clk_sel[di] = devm_clk_get(ipu->dev, di_clk_sel);
+		if (IS_ERR(ipu->di_clk_sel[di])) {
+			dev_err(ipu->dev, "di%u sel clk get failed\n", di);
+			return PTR_ERR(ipu->di_clk_sel[di]);
+		}
 	}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LCD_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0)
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1
+	if (ipu->id == 0)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[1], ipu->di_clk[1]);
+#endif
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0
+	if (ipu->id == 1)
+		clk_set_parent(ipu->pixel_clk_sel[0], ipu->di_clk[0]);
+#endif
+#endif
+
 	return 0;
 }
 
@@ -626,6 +623,12 @@ static int ipu_probe(struct platform_device *pdev)
 		ipu_cm_write(ipu, 0x00400000L | (IPU_MCU_T_DEFAULT << 18),
 			     IPU_DISP_GEN);
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	else {
+		ipu->fg_csc_type = ipu->bg_csc_type = CSC_NONE;
+		ipu->color_key_4rgb = true;
+	}
+#endif
 
 	/* setup ipu clk tree after ipu reset  */
 	ret = ipu_clk_setup_enable(ipu);
@@ -3457,3 +3460,529 @@ static void __exit ipu_gen_uninit(void)
 }
 
 module_exit(ipu_gen_uninit);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+/*!
+ * This function is called to initialize a logical IPU channel.
+ *
+ * @param	ipu	ipu handler
+ * @param       channel Input parameter for the logical channel ID to init.
+ *
+ * @param       params  Input parameter containing union of channel
+ *                      initialization parameters.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params)
+{
+	int ret = 0;
+	uint32_t ipu_conf;
+
+	dev_dbg(ipu->dev, "init channel = %d\n", IPU_CHAN_ID(channel));
+
+	ret = pm_runtime_get_sync(ipu->dev);
+	if (ret < 0) {
+		dev_err(ipu->dev, "ch = %d, pm_runtime_get failed:%d!\n",
+				IPU_CHAN_ID(channel), ret);
+		dump_stack();
+		return ret;
+	}
+	/*
+	 * Here, ret could be 1 if the device's runtime PM status was
+	 * already 'active', so clear it to be 0.
+	 */
+	ret = 0;
+
+	//_ipu_get(ipu);
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Re-enable error interrupts every time a channel is initialized */
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(5));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(6));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(9));
+	ipu_cm_write(ipu, 0xFFFFFFFF, IPU_INT_CTRL(10));
+
+	if (ipu->channel_init_mask & (1L << IPU_CHAN_ID(channel))) {
+		dev_warn(ipu->dev, "Warning: channel already initialized %d\n",
+			IPU_CHAN_ID(channel));
+	}
+
+	ipu_conf = ipu_cm_read(ipu, IPU_CONF);
+
+	switch (channel) {
+	case MEM_DC_SYNC:
+		if (params->mem_dc_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		ipu->dc_di_assignment[1] = params->mem_dc_sync.di;
+//		_ipu_dc_init(ipu, 1, params->mem_dc_sync.di,
+//			     params->mem_dc_sync.interlaced,
+//			     params->mem_dc_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dc_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_BG_SYNC:
+		if (params->mem_dp_bg_sync.di > 1) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		if (params->mem_dp_bg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_di_assignment[5] = params->mem_dp_bg_sync.di;
+//		_ipu_dp_init(ipu, channel, params->mem_dp_bg_sync.in_pixel_fmt,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+//		_ipu_dc_init(ipu, 5, params->mem_dp_bg_sync.di,
+//			     params->mem_dp_bg_sync.interlaced,
+//			     params->mem_dp_bg_sync.out_pixel_fmt);
+		ipu->di_use_count[params->mem_dp_bg_sync.di]++;
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	case MEM_FG_SYNC:
+		_ipu_dp_init(ipu, channel, params->mem_dp_fg_sync.in_pixel_fmt,
+			     params->mem_dp_fg_sync.out_pixel_fmt);
+
+		if (params->mem_dp_fg_sync.alpha_chan_en)
+			ipu->thrd_chan_en[IPU_CHAN_ID(channel)] = true;
+
+		ipu->dc_use_count++;
+		ipu->dp_use_count++;
+		ipu->dmfc_use_count++;
+		break;
+	default:
+		dev_err(ipu->dev, "Missing channel initialization\n");
+		break;
+	}
+
+	ipu->channel_init_mask |= 1L << IPU_CHAN_ID(channel);
+
+	ipu_cm_write(ipu, ipu_conf, IPU_CONF);
+
+err:
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_init_channel_late_init);
+
+/*!
+ * This function is called to initialize buffer(s) for logical IPU channel.
+ *
+ * @param	ipu		ipu handler
+ *
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       type            Input parameter which buffer to initialize.
+ *
+ * @param       pixel_fmt       Input parameter for pixel format of buffer.
+ *                              Pixel format is a FOURCC ASCII code.
+ *
+ * @param       width           Input parameter for width of buffer in pixels.
+ *
+ * @param       height          Input parameter for height of buffer in pixels.
+ *
+ * @param       stride          Input parameter for stride length of buffer
+ *                              in pixels.
+ *
+ * @param       rot_mode        Input parameter for rotation setting of buffer.
+ *                              A rotation setting other than
+ *                              IPU_ROTATE_VERT_FLIP
+ *                              should only be used for input buffers of
+ *                              rotation channels.
+ *
+ * @param       phyaddr_0       Input parameter buffer 0 physical address.
+ *
+ * @param       phyaddr_1       Input parameter buffer 1 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              double buffering mode.
+ *
+ * @param       phyaddr_2       Input parameter buffer 2 physical address.
+ *                              Setting this to a value other than NULL enables
+ *                              triple buffering mode, phyaddr_1 should not be
+ *                              NULL then.
+ *
+ * @param       u		private u offset for additional cropping,
+ *				zero if not used.
+ *
+ * @param       v		private v offset for additional cropping,
+ *				zero if not used.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				dma_addr_t phyaddr_2,
+				uint32_t u, uint32_t v)
+{
+	uint32_t reg;
+	uint32_t dma_chan;
+	uint32_t burst_size;
+
+	dma_chan = channel_2_dma(channel, type);
+	if (!idma_is_valid(dma_chan))
+		return -EINVAL;
+
+	if (stride < width * bytes_per_pixel(pixel_fmt))
+		stride = width * bytes_per_pixel(pixel_fmt);
+
+	if (stride % 4) {
+		dev_err(ipu->dev,
+			"Stride not 32-bit aligned, stride = %d\n", stride);
+		return -EINVAL;
+	}
+	/* IC & IRT channels' width must be multiple of 8 pixels */
+	if ((_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan))
+		&& (width % 8)) {
+		dev_err(ipu->dev, "Width must be 8 pixel multiple\n");
+		return -EINVAL;
+	}
+
+	if (_ipu_is_vdi_out_chan(dma_chan) &&
+		((width < 16) || (height < 16) || (width % 2) || (height % 4))) {
+		dev_err(ipu->dev, "vdi width/height limited err\n");
+		return -EINVAL;
+	}
+
+	/* IPUv3EX and IPUv3M support triple buffer */
+	if ((!_ipu_is_trb_chan(ipu, dma_chan)) && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d doesn't support triple buffer "
+				   "mode\n", dma_chan);
+		return -EINVAL;
+	}
+	if (!phyaddr_1 && phyaddr_2) {
+		dev_err(ipu->dev, "Chan%d's buf1 physical addr is NULL for "
+				   "triple buffer mode\n", dma_chan);
+		return -EINVAL;
+	}
+
+	mutex_lock(&ipu->mutex_lock);
+
+	/* Build parameter memory data for DMA channel */
+	_ipu_ch_param_init(ipu, dma_chan, pixel_fmt, width, height, stride, u, v, 0,
+			   phyaddr_0, phyaddr_1, phyaddr_2);
+
+	/* Set correlative channel parameter of local alpha channel */
+	if ((_ipu_is_ic_graphic_chan(dma_chan) ||
+	     _ipu_is_dp_graphic_chan(dma_chan)) &&
+	    (ipu->thrd_chan_en[IPU_CHAN_ID(channel)] == true)) {
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, true);
+		_ipu_ch_param_set_alpha_buffer_memory(ipu, dma_chan);
+		_ipu_ch_param_set_alpha_condition_read(ipu, dma_chan);
+		/* fix alpha width as 8 and burst size as 16*/
+		_ipu_ch_params_set_alpha_width(ipu, dma_chan, 8);
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+	} else if (_ipu_is_ic_graphic_chan(dma_chan) &&
+		   ipu_pixel_format_has_alpha(pixel_fmt))
+		_ipu_ch_param_set_alpha_use_separate_channel(ipu, dma_chan, false);
+
+	if (rot_mode)
+		_ipu_ch_param_set_rotation(ipu, dma_chan, rot_mode);
+
+	/* IC and ROT channels have restriction of 8 or 16 pix burst length */
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_vdi_out_chan(dma_chan)) {
+		if ((width % 16) == 0)
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 16);
+		else
+			_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+	} else if (_ipu_is_irt_chan(dma_chan)) {
+		_ipu_ch_param_set_burst_size(ipu, dma_chan, 8);
+		_ipu_ch_param_set_block_mode(ipu, dma_chan);
+	} else if (_ipu_is_dmfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+//		_ipu_dmfc_set_wait4eot(ipu, dma_chan, width);
+		_ipu_dmfc_set_burst_size(ipu, dma_chan, burst_size);
+	}
+
+	if (_ipu_disp_chan_is_interlaced(ipu, channel) ||
+		ipu->chan_is_interlaced[dma_chan])
+		_ipu_ch_param_set_interlaced_scan(ipu, dma_chan);
+
+	if (_ipu_is_ic_chan(dma_chan) || _ipu_is_irt_chan(dma_chan) ||
+		_ipu_is_vdi_out_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		_ipu_ic_idma_init(ipu, dma_chan, width, height, burst_size,
+			rot_mode);
+	} else if (_ipu_is_smfc_chan(dma_chan)) {
+		burst_size = _ipu_ch_param_get_burst_size(ipu, dma_chan);
+		/*
+		 * This is different from IPUv3 spec, but it is confirmed
+		 * in IPUforum that SMFC burst size should be NPB[6:3]
+		 * when IDMAC works in 16-bit generic data mode.
+		 */
+		if (pixel_fmt == IPU_PIX_FMT_GENERIC)
+			/* 8 bits per pixel */
+			burst_size = burst_size >> 4;
+		else if (pixel_fmt == IPU_PIX_FMT_GENERIC_16)
+			/* 16 bits per pixel */
+			burst_size = burst_size >> 3;
+		else
+			burst_size = burst_size >> 2;
+		_ipu_smfc_set_burst_size(ipu, channel, burst_size-1);
+	}
+
+	switch (dma_chan) {
+	case 0:
+	case 1:
+	case 2:
+	case 3:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch0123_axi);
+		break;
+	case 23:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch23_axi);
+		break;
+	case 27:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch27_axi);
+		break;
+	case 28:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->ch28_axi);
+		break;
+	default:
+		_ipu_ch_param_set_axi_id(ipu, dma_chan, ipu->normal_axi);
+		break;
+	}
+
+	if (idma_is_set(ipu, IDMAC_CHA_PRI(dma_chan), dma_chan) &&
+	    ipu->devtype == IPUv3H) {
+		uint32_t reg = IDMAC_CH_LOCK_EN_1(ipu->devtype);
+		uint32_t value = 0;
+
+		switch (dma_chan) {
+		case 5:
+			value = 0x3;
+			break;
+		case 11:
+			value = 0x3 << 2;
+			break;
+		case 12:
+			value = 0x3 << 4;
+			break;
+		case 14:
+			value = 0x3 << 6;
+			break;
+		case 15:
+			value = 0x3 << 8;
+			break;
+		case 20:
+			value = 0x3 << 10;
+			break;
+		case 21:
+			value = 0x3 << 12;
+			break;
+		case 22:
+			value = 0x3 << 14;
+			break;
+		case 23:
+			value = 0x3 << 16;
+			break;
+		case 27:
+			value = 0x3 << 18;
+			break;
+		case 28:
+			value = 0x3 << 20;
+			break;
+		case 45:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 0;
+			break;
+		case 46:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 2;
+			break;
+		case 47:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 4;
+			break;
+		case 48:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 6;
+			break;
+		case 49:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 8;
+			break;
+		case 50:
+			reg = IDMAC_CH_LOCK_EN_2(ipu->devtype);
+			value = 0x3 << 10;
+			break;
+		default:
+			break;
+		}
+		value |= ipu_idmac_read(ipu, reg);
+		ipu_idmac_write(ipu, value, reg);
+	}
+
+	_ipu_ch_param_dump(ipu, dma_chan);
+
+	if (phyaddr_2 && ipu->devtype >= IPUv3EX) {
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg |= idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		/* Set IDMAC third buffer's cpmem number */
+		/* See __ipu_ch_get_third_buf_cpmem_num() for mapping */
+		ipu_idmac_write(ipu, 0x00444047L,
+				IDMAC_SUB_ADDR_4(ipu->devtype));
+		ipu_idmac_write(ipu, 0x46004241L,
+				IDMAC_SUB_ADDR_3(ipu->devtype));
+		ipu_idmac_write(ipu, 0x00000045L,
+				IDMAC_SUB_ADDR_1(ipu->devtype));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, tri_cur_buf_mask(dma_chan),
+				IPU_CHA_TRIPLE_CUR_BUF(ipu->devtype, dma_chan));
+	} else {
+		reg = ipu_cm_read(ipu,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+		reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg,
+				IPU_CHA_TRB_MODE_SEL(ipu->devtype, dma_chan));
+
+		reg = ipu_cm_read(ipu, IPU_CHA_DB_MODE_SEL(dma_chan));
+		if (phyaddr_1)
+			reg |= idma_mask(dma_chan);
+		else
+			reg &= ~idma_mask(dma_chan);
+		ipu_cm_write(ipu, reg, IPU_CHA_DB_MODE_SEL(dma_chan));
+
+		/* Reset to buffer 0 */
+		ipu_cm_write(ipu, idma_mask(dma_chan),
+				IPU_CHA_CUR_BUF(ipu->devtype, dma_chan));
+
+	}
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_init_channel_buffer_late_init);
+
+/*!
+ * This function disables the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to disable interrupt for.
+ *
+ */
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg &= ~IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_disable_irq_late_init);
+
+/*!
+ * This function clears the interrupt for the specified interrupt line.
+ * The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to clear interrupt for.
+ *
+ */
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq)
+{
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+}
+EXPORT_SYMBOL(ipu_clear_irq_late_init);
+
+/*!
+ * This function registers an interrupt handler function for the specified
+ * interrupt line. The interrupt lines are defined in \b ipu_irq_line enum.
+ *
+ * @param	ipu		ipu handler
+ * @param       irq             Interrupt line to get status for.
+ *
+ * @param       handler         Input parameter for address of the handler
+ *                              function.
+ *
+ * @param       irq_flags       Flags for interrupt mode. Currently not used.
+ *
+ * @param       devname         Input parameter for string name of driver
+ *                              registering the handler.
+ *
+ * @param       dev_id          Input parameter for pointer of data to be
+ *                              passed to the handler.
+ *
+ * @return      This function returns 0 on success or negative error code on
+ *              fail.
+ */
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+		    irqreturn_t(*handler) (int, void *),
+		    uint32_t irq_flags, const char *devname, void *dev_id)
+{
+	uint32_t reg;
+	unsigned long lock_flags;
+	int ret = 0;
+
+	BUG_ON(irq >= IPU_IRQ_COUNT);
+
+	spin_lock_irqsave(&ipu->int_reg_spin_lock, lock_flags);
+
+	if (ipu->irq_list[irq].handler != NULL) {
+		dev_err(ipu->dev,
+			"handler already installed on irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Check sync interrupt handler only, since we do nothing for
+	 * error interrupts but than print out register values in the
+	 * error interrupt source handler.
+	 */
+	if (_ipu_is_sync_irq(irq) && (handler == NULL)) {
+		dev_err(ipu->dev, "handler is NULL for sync irq %d\n", irq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ipu->irq_list[irq].handler = handler;
+	ipu->irq_list[irq].flags = irq_flags;
+	ipu->irq_list[irq].dev_id = dev_id;
+	ipu->irq_list[irq].name = devname;
+
+	/* clear irq stat for previous use */
+	ipu_cm_write(ipu, IPUIRQ_2_MASK(irq),
+			IPUIRQ_2_STATREG(ipu->devtype, irq));
+	/* enable the interrupt */
+	reg = ipu_cm_read(ipu, IPUIRQ_2_CTRLREG(irq));
+	reg |= IPUIRQ_2_MASK(irq);
+	ipu_cm_write(ipu, reg, IPUIRQ_2_CTRLREG(irq));
+out:
+	spin_unlock_irqrestore(&ipu->int_reg_spin_lock, lock_flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(ipu_request_irq_late_init);
+#endif
diff --git a/drivers/mxc/ipu3/ipu_disp.c b/drivers/mxc/ipu3/ipu_disp.c
index f7044c2..c5255c0 100644
--- a/drivers/mxc/ipu3/ipu_disp.c
+++ b/drivers/mxc/ipu3/ipu_disp.c
@@ -1957,3 +1957,158 @@ void ipu_disp_init(struct ipu_soc *ipu)
 	_ipu_init_dc_mappings(ipu);
 	_ipu_dmfc_init(ipu, DMFC_NORMAL, 1);
 }
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+
+/*!
+ * This function sets the foreground and background plane global alpha blending
+ * modes. This function also sets the DP graphic plane according to the
+ * parameter of IPUv3 DP channel.
+ *
+ * @param	ipu		ipu handler
+ * @param	channel		IPUv3 DP channel
+ *
+ * @param       enable          Boolean to enable or disable global alpha
+ *                              blending. If disabled, local blending is used.
+ *
+ * @param       alpha           Global alpha value.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint8_t alpha)
+{
+	uint32_t reg;
+	uint32_t flow;
+	bool bg_chan;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_BG_ASYNC0 ||
+	    channel == MEM_BG_ASYNC1)
+		bg_chan = true;
+	else
+		bg_chan = false;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	if (bg_chan) {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWSEL, DP_COM_CONF(flow));
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0x00FFFFFFL;
+		ipu_dp_write(ipu, reg | ((uint32_t) alpha << 24),
+			     DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWAM, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_global_alpha_late_init);
+
+/*!
+ * This function sets the transparent color key for SDC graphic plane.
+ *
+ * @param	ipu		ipu handler
+ * @param       channel         Input parameter for the logical channel ID.
+ *
+ * @param       enable          Boolean to enable or disable color key
+ *
+ * @param       colorKey        24-bit RGB color for transparent color key.
+ *
+ * @return      Returns 0 on success or negative error code on fail
+ */
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				bool enable, uint32_t color_key)
+{
+	uint32_t reg, flow;
+	int y, u, v;
+	int red, green, blue;
+
+	if (channel == MEM_BG_SYNC || channel == MEM_FG_SYNC)
+		flow = DP_SYNC;
+	else if (channel == MEM_BG_ASYNC0 || channel == MEM_FG_ASYNC0)
+		flow = DP_ASYNC0;
+	else if (channel == MEM_BG_ASYNC1 || channel == MEM_FG_ASYNC1)
+		flow = DP_ASYNC1;
+	else
+		return -EINVAL;
+
+	mutex_lock(&ipu->mutex_lock);
+
+	ipu->color_key_4rgb = true;
+	/* Transform color key from rgb to yuv if CSC is enabled */
+	if (((ipu->fg_csc_type == RGB2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == RGB2YUV)) ||
+			((ipu->fg_csc_type == YUV2YUV) && (ipu->bg_csc_type == YUV2YUV)) ||
+			((ipu->fg_csc_type == YUV2RGB) && (ipu->bg_csc_type == YUV2RGB))) {
+
+		dev_dbg(ipu->dev, "color key 0x%x need change to yuv fmt\n", color_key);
+
+		red = (color_key >> 16) & 0xFF;
+		green = (color_key >> 8) & 0xFF;
+		blue = color_key & 0xFF;
+
+		y = _rgb_to_yuv(0, red, green, blue);
+		u = _rgb_to_yuv(1, red, green, blue);
+		v = _rgb_to_yuv(2, red, green, blue);
+		color_key = (y << 16) | (u << 8) | v;
+
+		ipu->color_key_4rgb = false;
+
+		dev_dbg(ipu->dev, "color key change to yuv fmt 0x%x\n", color_key);
+	}
+
+	if (enable) {
+		reg = ipu_dp_read(ipu, DP_GRAPH_WIND_CTRL(flow)) & 0xFF000000L;
+		ipu_dp_write(ipu, reg | color_key, DP_GRAPH_WIND_CTRL(flow));
+
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg | DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	} else {
+		reg = ipu_dp_read(ipu, DP_COM_CONF(flow));
+		ipu_dp_write(ipu, reg & ~DP_COM_CONF_GWCKE, DP_COM_CONF(flow));
+	}
+
+	reg = ipu_cm_read(ipu, IPU_SRM_PRI2) | 0x8;
+	ipu_cm_write(ipu, reg, IPU_SRM_PRI2);
+
+	mutex_unlock(&ipu->mutex_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(ipu_disp_set_color_key_late_init);
+
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel,
+				int16_t *x_pos, int16_t *y_pos)
+{
+	int ret;
+
+	mutex_lock(&ipu->mutex_lock);
+	ret = _ipu_disp_get_window_pos(ipu, channel, x_pos, y_pos);
+	mutex_unlock(&ipu->mutex_lock);
+	return ret;
+}
+EXPORT_SYMBOL(ipu_disp_get_window_pos_late_init);
+#endif
diff --git a/drivers/video/mxc/ldb.c b/drivers/video/mxc/ldb.c
index ca53344..15c795d9 100644
--- a/drivers/video/mxc/ldb.c
+++ b/drivers/video/mxc/ldb.c
@@ -110,6 +110,11 @@ struct ldb_data {
 	struct clk *div_3_5_clk[2];
 	struct clk *div_7_clk[2];
 	struct clk *div_sel_clk[2];
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1)  || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	bool fb_reg;
+#endif
 };
 
 static const struct crtc_mux imx6q_lvds0_crtc_mux[] = {
@@ -437,6 +442,13 @@ static int ldb_setup(struct mxc_dispdrv_handle *mddh,
 		return ret;
 	}
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return 0;
+	}
+#endif
 
 	if (ldb->clk_fixup) {
 		/*
@@ -528,6 +540,14 @@ static int ldb_enable(struct mxc_dispdrv_handle *mddh,
 
 	bus_mux = ldb->buses[chno];
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return 0;
+	}
+#endif
+
 	if (ldb->spl_mode || ldb->dual_mode) {
 		other_chno = chno ? 0 : 1;
 		clk_prepare_enable(ldb->ldb_di_clk[other_chno]);
@@ -569,6 +589,14 @@ static void ldb_disable(struct mxc_dispdrv_handle *mddh,
 	if (ret < 0)
 		return;
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	if (ldb->fb_reg == false) {
+		return;
+	}
+#endif
+
 	if (ldb->spl_mode || ldb->dual_mode) {
 		ldb->ctrl &= ~(LDB_CH1_MODE_MASK | LDB_CH0_MODE_MASK);
 		other_chno = chno ? 0 : 1;
@@ -582,12 +610,30 @@ static void ldb_disable(struct mxc_dispdrv_handle *mddh,
 	return;
 }
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+void ldb_disp_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct ldb_data *ldb = mxc_dispdrv_getdata(disp);
+
+	ldb->fb_reg = true;
+}
+#endif
+
 static struct mxc_dispdrv_driver ldb_drv = {
 	.name		= DRIVER_NAME,
 	.init		= ldb_init,
 	.setup		= ldb_setup,
 	.enable		= ldb_enable,
-	.disable	= ldb_disable
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU1_DI1) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_LVDS_IPU2_DI1)
+	.disable        = ldb_disable,
+	.late_init_done = ldb_disp_late_init_done
+#else
+	.disable        = ldb_disable
+#endif
 };
 
 enum {
diff --git a/drivers/video/mxc/mxc_dispdrv.h b/drivers/video/mxc/mxc_dispdrv.h
index 58d8a07..1d480f6 100644
--- a/drivers/video/mxc/mxc_dispdrv.h
+++ b/drivers/video/mxc/mxc_dispdrv.h
@@ -40,6 +40,11 @@ struct mxc_dispdrv_driver {
 	void (*disable) (struct mxc_dispdrv_handle *, struct fb_info *);
 	/* display driver setup function, called at early part of fb_set_par */
 	int (*setup) (struct mxc_dispdrv_handle *, struct fb_info *fbi);
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	/* display driver late init done. */
+	void (*late_init_done) (struct mxc_dispdrv_handle *);
+#endif
 };
 
 struct mxc_dispdrv_handle *mxc_dispdrv_register(struct mxc_dispdrv_driver *drv);
diff --git a/drivers/video/mxc/mxc_hdmi.c b/drivers/video/mxc/mxc_hdmi.c
index 7c636b7..7f85fcf 100644
--- a/drivers/video/mxc/mxc_hdmi.c
+++ b/drivers/video/mxc/mxc_hdmi.c
@@ -1746,8 +1746,14 @@ static void mxc_hdmi_clear_overflow(struct mxc_hdmi *hdmi)
 static void hdmi_enable_overflow_interrupts(void)
 {
 	pr_debug("%s\n", __func__);
+
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	/* Skip */
+#else
 	hdmi_writeb(0, HDMI_FC_MASK2);
 	hdmi_writeb(0, HDMI_IH_MUTE_FC_STAT2);
+#endif
 }
 
 static void hdmi_disable_overflow_interrupts(void)
@@ -2003,6 +2009,10 @@ static void hotplug_worker(struct work_struct *work)
 	unsigned long flags;
 	char event_string[32];
 	char *envp[] = { event_string, NULL };
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	int edid_status = HDMI_EDID_FAIL;
+#endif
 
 	phy_int_stat = hdmi->latest_intr_stat;
 	phy_int_pol = hdmi_readb(HDMI_PHY_POL0);
@@ -2016,7 +2026,27 @@ static void hotplug_worker(struct work_struct *work)
 		if (phy_int_pol & HDMI_PHY_HPD) {
 			/* Plugin event */
 			dev_dbg(&hdmi->pdev->dev, "EVENT=plugin\n");
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			if (hdmi->fb_reg)
+				mxc_hdmi_cable_connected(hdmi);
+			else {
+				hdmi->cable_plugin = true;
+				hdmi_set_blank_state(1);
+				/* Plugin event */
+				dev_dbg(&hdmi->pdev->dev, "cable plugin\n");
+				edid_status = mxc_hdmi_read_edid(hdmi);
+
+				/* Read EDID again if first EDID read failed */
+				if (edid_status == HDMI_EDID_NO_MODES ||
+					edid_status == HDMI_EDID_FAIL) {
+					dev_info(&hdmi->pdev->dev, "Read EDID again\n");
+					edid_status = mxc_hdmi_read_edid(hdmi);
+				}
+			}
+#else
 			mxc_hdmi_cable_connected(hdmi);
+#endif
 
 			/* Make HPD intr active low to capture unplug event */
 			val = hdmi_readb(HDMI_PHY_POL0);
@@ -2048,6 +2078,10 @@ static void hotplug_worker(struct work_struct *work)
 			mxc_hdmi_cec_handle(0x100);
 #endif
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+        defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			hdmi->fb_reg = true;
+#endif
 		} else
 			dev_dbg(&hdmi->pdev->dev, "EVENT=none?\n");
 	}
@@ -2260,6 +2294,19 @@ static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
 
 }
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+void mxc_hdmi_late_init_done(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi->fb_reg = true;
+	hdmi->dft_mode_set = false;
+}
+#endif
+
 /* Wait until we are registered to enable interrupts */
 static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
 {
@@ -2288,7 +2335,14 @@ static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
 	/* Unmute interrupts */
 	hdmi_writeb(~HDMI_IH_MUTE_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);
 
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	hdmi->phy_enabled = true;
+	hdmi->blank = FB_BLANK_UNBLANK;
+	/* Skip hdmi->fb_reg. */
+#else
 	hdmi->fb_reg = true;
+#endif
 
 	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
 
@@ -2318,6 +2372,22 @@ static int mxc_hdmi_fb_event(struct notifier_block *nb,
 
 	case FB_EVENT_MODE_CHANGE:
 		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_MODE_CHANGE\n");
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+		if (!hdmi->fb_reg) {
+			struct fb_videomode m;
+
+			fb_var_to_videomode(&m, &hdmi->fbi->var);
+			hdmi->blank = FB_BLANK_UNBLANK;
+
+			if (!hdmi->requesting_vga_for_initialization) {
+				/* Save mode if this isn't the result of requesting
+				 * vga default. */
+				memcpy(&hdmi->previous_non_vga_mode, &m,
+						sizeof(struct fb_videomode));
+			}
+		}
+#endif
 		if (hdmi->fb_reg)
 			mxc_hdmi_setup(hdmi, val);
 		break;
@@ -2369,7 +2439,12 @@ static int mxc_hdmi_fb_event(struct notifier_block *nb,
 			clk_enable(hdmi->mipi_core_clk);
 			clk_enable(hdmi->hdmi_iahb_clk);
 			clk_enable(hdmi->hdmi_isfr_clk);
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+			mxc_hdmi_setup(hdmi, val);
+#else
 			mxc_hdmi_phy_init(hdmi);
+#endif
 		}
 		break;
 
@@ -2716,6 +2791,10 @@ static struct mxc_dispdrv_driver mxc_hdmi_drv = {
 	.deinit	= mxc_hdmi_disp_deinit,
 	.enable = mxc_hdmi_power_on,
 	.disable = mxc_hdmi_power_off,
+#if defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU1_DI0) || \
+	defined(CONFIG_MX6_CLK_FOR_BOOTUI_TRANS_HDMI_IPU2_DI0)
+	.late_init_done = mxc_hdmi_late_init_done,
+#endif
 };
 
 
diff --git a/drivers/video/mxc/mxc_ipuv3_fb.c b/drivers/video/mxc/mxc_ipuv3_fb.c
index eb9b2f2..6a2f637 100644
--- a/drivers/video/mxc/mxc_ipuv3_fb.c
+++ b/drivers/video/mxc/mxc_ipuv3_fb.c
@@ -77,6 +77,9 @@ struct mxcfb_info {
 	bool overlay;
 	bool alpha_chan_en;
 	bool late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	bool late_init_idmac_done;
+#endif
 	bool first_set_par;
 	bool resolve;
 	bool prefetch;
@@ -470,7 +473,15 @@ static int _setup_disp_channel1(struct fb_info *fbi)
 		if (mxc_fbi->alpha_chan_en)
 			params.mem_dp_bg_sync.alpha_chan_en = true;
 	}
+
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init)
+		ipu_init_channel_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+	else
+		ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#else
 	ipu_init_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, &params);
+#endif
 
 	return 0;
 }
@@ -893,6 +904,29 @@ static int _setup_disp_channel2(struct fb_info *fbi)
 							       IPU_INPUT_BUFFER, 2));
 		}
 	} else if (!mxc_fbi->on_the_fly && !mxc_fbi->prefetch) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			mxc_fbi->cur_ipu_buf = 0;
+			retval = ipu_init_channel_buffer_late_init(mxc_fbi->ipu,
+						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+						 fbi_to_pixfmt(fbi, false),
+						 fbi->var.xres, fbi->var.yres,
+						 ipu_stride,
+						 fbi->var.rotate,
+						 ipu_base,
+						 ipu_base,
+						 fbi->var.accel_flags &
+						FB_ACCEL_DOUBLE_FLAG ? 0 : ipu_base,
+						 0, 0);
+			if (retval) {
+				dev_err(fbi->device,
+					"ipu_init_channel_buffer error %d\n", retval);
+				return retval;
+			}
+
+			mxc_fbi->late_init_idmac_done = true;
+		} else {
+#endif
 		retval = ipu_init_channel_buffer(mxc_fbi->ipu,
 						 mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
 						 mxc_fbi->on_the_fly ? mxc_fbi->final_pfmt :
@@ -910,6 +944,9 @@ static int _setup_disp_channel2(struct fb_info *fbi)
 				"ipu_init_channel_buffer error %d\n", retval);
 			return retval;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 		/* update u/v offset */
 		if (!mxc_fbi->prefetch)
 			ipu_update_channel_offset(mxc_fbi->ipu, mxc_fbi->ipu_ch,
@@ -955,6 +992,23 @@ static bool mxcfb_need_to_set_par(struct fb_info *fbi)
 {
 	struct mxcfb_info *mxc_fbi = fbi->par;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if ((mxc_fbi->cur_var.xres != fbi->var.xres) ||
+			(mxc_fbi->cur_var.yres != fbi->var.yres) ||
+			(mxc_fbi->cur_var.bits_per_pixel != fbi->var.bits_per_pixel)) {
+			mxc_fbi->late_init = false;
+
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+			return true;
+		}
+
+		if (mxc_fbi->late_init_idmac_done)
+			return false;
+	}
+#endif
+
 	if ((fbi->var.activate & FB_ACTIVATE_FORCE) &&
 	    (fbi->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)
 		return true;
@@ -1153,6 +1207,42 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	if (on_the_fly)
 		dev_dbg(fbi->device, "Reconfiguring framebuffer on the fly\n");
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxc_fbi->late_init) {
+		if (ovfbi_enable) {
+			ov_pos_ret = ipu_disp_get_window_pos_late_init(
+							mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch,
+							&ov_pos_x, &ov_pos_y);
+			if (ov_pos_ret < 0)
+				dev_err(fbi->device, "Get overlay pos failed, dispdrv:%s.\n",
+							mxc_fbi->dispdrv->drv->name);
+
+			if (!on_the_fly) {
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_irq);
+				ipu_clear_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				ipu_disable_irq_late_init(mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch_nf_irq);
+				if (mxc_fbi_fg->cur_prefetch) {
+					ipu_prg_disable(mxc_fbi_fg->ipu_id, mxc_fbi_fg->pre_num);
+					ipu_pre_disable(mxc_fbi_fg->pre_num);
+					ipu_pre_free(&mxc_fbi_fg->pre_num);
+				}
+			}
+		}
+
+		if (!on_the_fly) {
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_irq);
+			ipu_clear_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			ipu_disable_irq_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch_nf_irq);
+			if (mxc_fbi->cur_prefetch) {
+				ipu_prg_disable(mxc_fbi->ipu_id, mxc_fbi->pre_num);
+				ipu_pre_disable(mxc_fbi->pre_num);
+				ipu_pre_free(&mxc_fbi->pre_num);
+			}
+                }
+	} else {
+#endif
 	if (ovfbi_enable) {
 		ov_pos_ret = ipu_disp_get_window_pos(
 						mxc_fbi_fg->ipu, mxc_fbi_fg->ipu_ch,
@@ -1197,6 +1287,10 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	if (mxc_fbi->first_set_par && mxc_fbi->late_init)
 		ipu_disable_hsp_clk(mxc_fbi->ipu);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
+
 	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
 	if (mxc_fbi->resolve && mxc_fbi->gpu_sec_buf_off) {
 		if (fbi->var.vmode & FB_VMODE_YWRAP)
@@ -1214,12 +1308,14 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	}
 
 	if (mxc_fbi->first_set_par) {
+#ifndef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
 		/*
 		 * Clear the screen in case uboot fb pixel format is not
 		 * the same to kernel fb pixel format.
 		 */
 		if (mxc_fbi->late_init)
 			memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+#endif
 
 		mxc_fbi->first_set_par = false;
 	}
@@ -1289,6 +1385,9 @@ static int mxcfb_set_par(struct fb_info *fbi)
 	}
 
 	if (!mxc_fbi->overlay && !on_the_fly) {
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (!mxc_fbi->late_init) {
+#endif
 		uint32_t out_pixel_fmt;
 
 		memset(&sig_cfg, 0, sizeof(sig_cfg));
@@ -1330,6 +1429,9 @@ static int mxcfb_set_par(struct fb_info *fbi)
 				"mxcfb: Error initializing panel.\n");
 			return -EINVAL;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 
 		fbi->mode =
 		    (struct fb_videomode *)fb_match_mode(&fbi->var,
@@ -1571,6 +1673,11 @@ static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 			bg_yres = fbi_tmp->var.yres;
 		}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			ipu_disp_get_window_pos_late_init(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
+		else
+#endif
 		ipu_disp_get_window_pos(mxc_fbi->ipu, mxc_fbi->ipu_ch, &pos_x, &pos_y);
 
 		if ((var->xres + pos_x) > bg_xres)
@@ -2309,6 +2416,12 @@ static int mxcfb_blank(int blank, struct fb_info *info)
 	case FB_BLANK_VSYNC_SUSPEND:
 	case FB_BLANK_HSYNC_SUSPEND:
 	case FB_BLANK_NORMAL:
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init) {
+			if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->late_init_done)
+				mxc_fbi->dispdrv->drv->late_init_done(mxc_fbi->dispdrv);
+		}
+#endif
 		if (mxc_fbi->dispdrv && mxc_fbi->dispdrv->drv->disable)
 			mxc_fbi->dispdrv->drv->disable(mxc_fbi->dispdrv, info);
 		ipu_disable_channel(mxc_fbi->ipu, mxc_fbi->ipu_ch, true);
@@ -2320,6 +2433,10 @@ static int mxcfb_blank(int blank, struct fb_info *info)
 			ipu_pre_disable(mxc_fbi->pre_num);
 			ipu_pre_free(&mxc_fbi->pre_num);
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxc_fbi->late_init)
+			mxc_fbi->late_init = false;
+#endif
 		break;
 	case FB_BLANK_UNBLANK:
 		info->var.activate = (info->var.activate & ~FB_ACTIVATE_MASK) |
@@ -3150,6 +3267,36 @@ static int mxcfb_register(struct fb_info *fbi)
 	fb_var_to_videomode(&m, &fbi->var);
 	fb_add_videomode(&m, &fbi->modelist);
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
+				mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering EOF irq handler.\n");
+				ret = -EBUSY;
+				goto err0;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_irq);
+
+			if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq,
+				mxcfb_nf_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
+				dev_err(fbi->device, "Error registering NFACK irq handler.\n");
+				ret = -EBUSY;
+				goto err1;
+			}
+			ipu_disable_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_ch_nf_irq);
+
+			if (mxcfbi->ipu_alp_ch_irq != -1) {
+				if (ipu_request_irq_late_init(mxcfbi->ipu, mxcfbi->ipu_alp_ch_irq,
+							mxcfb_alpha_irq_handler, IPU_IRQF_ONESHOT,
+							MXCFB_NAME, fbi) != 0) {
+					dev_err(fbi->device, "Error registering alpha irq "
+							"handler.\n");
+					ret = -EBUSY;
+					goto err3;
+				}
+			}
+		} else {
+#endif
 	if (ipu_request_irq(mxcfbi->ipu, mxcfbi->ipu_ch_irq,
 		mxcfb_irq_handler, IPU_IRQF_ONESHOT, MXCFB_NAME, fbi) != 0) {
 		dev_err(fbi->device, "Error registering EOF irq handler.\n");
@@ -3174,6 +3321,9 @@ static int mxcfb_register(struct fb_info *fbi)
 			ret = -EBUSY;
 			goto err2;
 		}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	}
+#endif
 
 	if (!mxcfbi->late_init) {
 		fbi->var.activate |= FB_ACTIVATE_FORCE;
@@ -3216,6 +3366,13 @@ static int mxcfb_register(struct fb_info *fbi)
 	if (ret < 0)
 		goto err5;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (mxcfbi->late_init && (mxcfbi->next_blank == FB_BLANK_UNBLANK)) {
+		mxcfbi->cur_var = fbi->var;
+		fbi->mode =(struct fb_videomode *)fb_match_mode(&fbi->var, &fbi->modelist);
+	}
+#endif
+
 	return ret;
 err5:
 	if (mxcfbi->next_blank == FB_BLANK_UNBLANK) {
@@ -3259,6 +3416,9 @@ static int mxcfb_setup_overlay(struct platform_device *pdev,
 		struct fb_info *fbi_bg, struct resource *res)
 {
 	struct fb_info *ovfbi;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	struct ipuv3_fb_platform_data *plat_data = pdev->dev.platform_data;
+#endif
 	struct mxcfb_info *mxcfbi_bg = (struct mxcfb_info *)fbi_bg->par;
 	struct mxcfb_info *mxcfbi_fg;
 	int ret = 0;
@@ -3287,6 +3447,9 @@ static int mxcfb_setup_overlay(struct platform_device *pdev,
 	mxcfbi_fg->prefetch = false;
 	mxcfbi_fg->resolve = false;
 	mxcfbi_fg->pre_num = -1;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi_fg->late_init = plat_data->late_init;
+#endif
 
 	/* Need dummy values until real panel is configured */
 	ovfbi->var.xres = 240;
@@ -3354,6 +3517,9 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 	int len;
 	u32 bpp, int_clk;
 	u32 late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	u32 fb_base, fb_size;
+#endif
 
 	err = of_property_read_string(np, "disp_dev", &disp_dev);
 	if (err < 0) {
@@ -3383,6 +3549,17 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 		dev_dbg(&pdev->dev, "get of property late_init fail\n");
 		return err;
 	}
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	err = of_property_read_u32(np, "fb_base", &fb_base);
+	if (err) {
+		fb_base = 0;
+	}
+
+	err = of_property_read_u32(np, "fb_size", &fb_size);
+	if (err) {
+		fb_size = 0;
+	}
+#endif
 
 	plat_data->prefetch = of_property_read_bool(np, "prefetch");
 
@@ -3420,6 +3597,10 @@ static int mxcfb_get_of_property(struct platform_device *pdev,
 	plat_data->default_bpp = bpp;
 	plat_data->int_clk = (bool)int_clk;
 	plat_data->late_init = (bool)late_init;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	plat_data->res_base[0] = fb_base;
+	plat_data->res_size[0] = fb_size;
+#endif
 	return err;
 }
 
@@ -3475,6 +3656,10 @@ static int mxcfb_probe(struct platform_device *pdev)
 	mxcfbi->first_set_par = true;
 	mxcfbi->prefetch = plat_data->prefetch;
 	mxcfbi->pre_num = -1;
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	mxcfbi->late_init = plat_data->late_init;
+	mxcfbi->late_init_idmac_done = false;
+#endif
 	spin_lock_init(&mxcfbi->spin_lock);
 
 	ret = mxcfb_dispdrv_init(pdev, fbi);
@@ -3488,6 +3673,16 @@ static int mxcfb_probe(struct platform_device *pdev)
 		goto ipu_in_busy;
 	}
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+	if (plat_data->res_base[0] && plat_data->res_size[0]) {
+		fbi->fix.smem_len = plat_data->res_size[0];
+		fbi->fix.smem_start = plat_data->res_base[0];
+		fbi->screen_base = ioremap(fbi->fix.smem_start, fbi->fix.smem_len);
+		/* Do not clear the fb content drawn in bootloader. */
+		if (!mxcfbi->late_init)
+			memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	}
+#else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res && res->start && res->end) {
 		fbi->fix.smem_len = res->end - res->start + 1;
@@ -3497,6 +3692,7 @@ static int mxcfb_probe(struct platform_device *pdev)
 		if (!mxcfbi->late_init)
 			memset(fbi->screen_base, 0, fbi->fix.smem_len);
 	}
+#endif
 
 	mxcfbi->ipu = ipu_get_soc(mxcfbi->ipu_id);
 	if (IS_ERR(mxcfbi->ipu)) {
@@ -3520,9 +3716,19 @@ static int mxcfb_probe(struct platform_device *pdev)
 		if (ret < 0)
 			goto mxcfb_register_failed;
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		if (mxcfbi->late_init) {
+			ipu_disp_set_global_alpha_late_init(mxcfbi->ipu, mxcfbi->ipu_ch,
+						  true, 0x80);
+			ipu_disp_set_color_key_late_init(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
+		} else {
+#endif
 		ipu_disp_set_global_alpha(mxcfbi->ipu, mxcfbi->ipu_ch,
 					  true, 0x80);
 		ipu_disp_set_color_key(mxcfbi->ipu, mxcfbi->ipu_ch, false, 0);
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+		}
+#endif
 
 		res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 		ret = mxcfb_setup_overlay(pdev, fbi, res);
diff --git a/include/linux/ipu-v3.h b/include/linux/ipu-v3.h
index ae09614..8c181f4 100644
--- a/include/linux/ipu-v3.h
+++ b/include/linux/ipu-v3.h
@@ -767,4 +767,27 @@ struct ipuv3_fb_platform_data {
 	bool				resolve;
 };
 
+#ifdef CONFIG_MX6_CLK_FOR_BOOTUI_TRANS
+void ipu_disable_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+void ipu_clear_irq_late_init(struct ipu_soc *ipu, uint32_t irq);
+int ipu_request_irq_late_init(struct ipu_soc *ipu, uint32_t irq,
+                                irqreturn_t(*handler) (int, void *),
+                                uint32_t irq_flags, const char *devname, void *dev_id);
+int32_t ipu_disp_get_window_pos_late_init(struct ipu_soc *ipu, ipu_channel_t channel, int16_t *x_pos,
+                                int16_t *y_pos);
+int32_t ipu_disp_set_global_alpha_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                                  uint8_t alpha);
+int32_t ipu_disp_set_color_key_late_init(struct ipu_soc *ipu, ipu_channel_t channel, bool enable,
+                               uint32_t colorKey);
+int32_t ipu_init_channel_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_channel_params_t *params);
+int32_t ipu_init_channel_buffer_late_init(struct ipu_soc *ipu, ipu_channel_t channel, ipu_buffer_t type,
+                                uint32_t pixel_fmt,
+                                uint16_t width, uint16_t height,
+                                uint32_t stride,
+                                ipu_rotate_mode_t rot_mode,
+                                dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+                                dma_addr_t phyaddr_2,
+                                uint32_t u, uint32_t v);
+#endif
+
 #endif /* __LINUX_IPU_V3_H_ */
-- 
1.9.1

